<!-- Generated with EZOut 2.0.6: Install-Module EZOut or https://github.com/StartAutomating/EZOut -->
<Types>
  <Type>
    <Name>EZOut.Commands</Name>
    <Members>
      <ScriptMethod>
        <Name>Clear-FormatData</Name>
        <Script>
                        
    &lt;#
    .Synopsis
        Clears formatting to the current session.
    .Description
        The Clear-FormatData command removes the formatting data for the current session.
        The formatting data must have been added with Add-FormatData
    .Example
        Clear-FormatData
    .Link
        Push-FormatData
    .Link
        Pop-FormatData
    #&gt;
    [OutputType([Nullable])]
    param()

    #region Clear module and reset data
    $FormatModules.Values | Where-Object{ $_ } | Remove-Module
    $Script:FormatModules = @{}
    #endregion Clear module and reset data

                    </Script>
      </ScriptMethod>
      <ScriptMethod>
        <Name>Clear-TypeData</Name>
        <Script>
                        
    &lt;#
    .Synopsis
        Clears formatting to the current session.
    .Description
        The Clear-FormatData command removes the formatting data for the current session.
        The formatting data must have been added with Add-FormatData
    .Link
        Push-TypeData
    .Link
        Pop-TypeData
    #&gt;
    param(
    )


    process {
        $TypeModules.Values | Where-Object {$_} |Remove-Module
        $Script:TypeModules = @{}
    }

                    </Script>
      </ScriptMethod>
      <ScriptMethod>
        <Name>ConvertTo-PropertySet</Name>
        <Script>
                        
    &lt;#
    .Synopsis
        Converts Select-Object results to a property set
    .Description
        Converts Select-Object results to a named property set
        Named property sets can be requested from a property
    .Example
        Get-ChildItem |
            Select-Object Name, LastWriteTime, LastModifiedTime, CreationTime |
            ConvertTo-TypePropertySet -Name FileTimes |
            Out-TypeData |
            Add-TypeData

        Get-ChildItem |
            Select-Object filetimes
    .Link
        Out-TypeData
    .Link
        Add-TypeData
    #&gt;
    [OutputType([string])]
    [Alias('ConvertTo-TypePropertySet')]
    param(
    # The output from Select-Object
    [ValidateScript({
        if ($_.pstypenames[0] -notlike "Selected.*") {
            throw "Must pipe in the result of a select-object"
        }
        return $true
    })]
    [Parameter(ValueFromPipeline=$true,Mandatory=$true)]
    $SelectedObject,

    # The name of the selection set to create
    [Parameter(Mandatory=$true,Position=0)]
    $Name
    )

    begin {
        $list = New-Object Collections.ArrayList
    }

    process {
        $null = $list.Add($SelectedObject)
    }

    end {
        $groupedByType = $list | Group-Object { $_.pstypenames[0] } -AsHashTable

        foreach ($kv in $groupedByType.GetEnumerator()) {
            $shortTypeName = $kv.Key.Substring("Selected.".Length)
            $values = $kv.Value | Get-Member -MemberType Properties | Select-Object -ExpandProperty Name
            Write-TypeView -TypeName $shortTypeName -PropertySet @{
                $Name = $values
            }
        }
    }

                    </Script>
      </ScriptMethod>
      <ScriptMethod>
        <Name>Find-FormatView</Name>
        <Script>
                        
    &lt;#
    .Synopsis
        Finds a format view for a typename
    .Description
        Finds a format view for a given typename
    .Example
        Find-FormatView System.Diagnostics.Process
    .Link
        Get-FormatFile
    #&gt;
    param(
    # The name of the type of format view to find
    [ParameteR(Mandatory=$true,
        Position=0,
        ValueFromPipelineByPropertyName=$true,
        ValueFromPipeline=$true)][string]
    $TypeName
    )
    begin {
        $formatFiles = Get-FormatFile

        $allViews = $formatFiles |
            Select-Xml //View

        $selectionSets = $formatFiles |
            Select-Xml //SelectionSet |
            Select-Object @{
                Label='Name'
                Expression={$_.Node.Name}
            }, @{
                Label='Types'
                Expression={$_.Node.Types}
            }

        $viewByType = @{}

        $allViews |
            Where-Object {
                $selectionSetName = $_.Node.ViewSelectedBy.SelectionSetName
                if (-not $selectionSetName) {
                    $viewByType[$_.Node.ViewSelectedBy.TypeName] = $_.Node
                } else {
                    $selectionSetName
                }
            } |
            ForEach-Object {
                $node = $_.Node
                $selectionSet = $selectionSets |
                    Where-Object  { $_.Name -eq $node.ViewSelectedBy.SelectionSetName }
                $selectionSet.Types.TypeName |
                    Foreach-Object {
                        if ($viewByType.Contains($_)) {
                            $viewByType[$_] = @($viewByType[$_]) + $node
                        } else {
                            $viewByType[$_] = $node
                        }
                    }
            }
    }

    process {
        $formatByType= $formatFiles |
            Select-Xml //ViewSelectedBy/TypeName |
            Where-Object { $_.Node.'#text' -eq $TypeName }



        if ($formatByType) {
            foreach ($ft in $formatByType) {
                $psObject = $ft.Node.SelectSingleNode("../..")
                $psobject.psobject.typenames.Insert(0,"FormatView")
                $psobject
            }
        }
        $hasSelectionSet = $formatFiles | Select-Xml //SelectionSet |
            Where-Object { $_.Node.Types.TypeName -contains $TypeName } | Select-Object -Unique

        if ($hasSelectionSet) {
            $formatFiles |
                Select-Xml //ViewSelectedBy/SelectionSetName |
                Where-Object {$_.node.'#text' -eq $hasSelectionSet.Node.Name } |
                Select-Object -Unique |
                ForEach-Object {
                    $psObject = $_.Node.SelectSingleNode("../..") -as [psobject]
                    $psobject.psobject.typenames.Insert(0,"FormatView")
                    $psobject
                }
        }
    }

                    </Script>
      </ScriptMethod>
      <ScriptMethod>
        <Name>Format-Hashtable</Name>
        <Script>
                        
    &lt;#
    .Synopsis
        Takes an creates a script to recreate a hashtable
    .Description
        Allows you to take a hashtable and create a hashtable you would embed into a script.
        
        Handles nested hashtables and indents nested hashtables automatically.        
    .Example
        # Corrects the presentation of a PowerShell hashtable
        [Ordered]@{Foo='Bar';Baz='Bing';Boo=@{Bam='Blang'}} | Format-Hashtable
    .Outputs
        [string]
    .Outputs
        [ScriptBlock]   
    .Link
        about_hash_tables
    #&gt;    
    [OutputType([string], [ScriptBlock])]
    [Management.Automation.Cmdlet("Format", "Object")]
    [ValidateScript({return $true})]
    param(
    # The hashtable or PSObject that will be written as a PowerShell Hashtable
    [Parameter(Position=0,ValueFromPipeline,ValueFromPipelineByPropertyName)]
    [PSObject]
    $InputObject,

    # Returns the content as a script block, rather than a string    
    [switch]$AsScriptBlock,

    # If set, will return the hashtable and all nested hashtables as custom objects.
    [switch]$AsPSObject,

    # If set, items in the hashtable will be sorted alphabetically
    [Switch]$Sort,
    
    # If set, credentials will be expanded out into a hashtable containing the username and password.          
    [Switch]$ExpandCredential,

    # If set, the outputted hashtable will not contain any extra whitespace.
    [switch]$Compress,

    # If set, will embed ScriptBlocks as literal strings,
    # so that the resulting hashtable could work in data language mode.
    [switch]$Safe,

    # The maximum depth to enumerate.
    # Beneath this depth, items will simply be returned as $null.
    [int]$Depth
    )

    begin {
        $myCmd = $MyInvocation.MyCommand
        $myScriptBlock = $myCmd.ScriptBlock
    }

    process {
        if (-not $Compress) {
            $psCallstack = @(Get-PSCallStack)
            $callstack = @(foreach ($cs in $psCallstack) {
                if ($cs.InvocationInfo.MyCommand.ScriptBlock -eq $myCmd.ScriptBlock) {
                    $cs
                }
            })
        } else {
            $callstack = @()
        }

        $myParams = @{} + $PSBoundParameters
        $myParams.Remove('InputObject')
        $CurrentDepth = $callStack.Count
        
        if ($Depth -and $CurrentDepth -gt $Depth) {
            return '$null'
        }

        

        if ($inputObject -and 
            $inputObject -isnot [Collections.IDictionary] -and 
            $inputObject -isnot [string] -and 
            (-not $InputObject.GetType().IsPrimitive) -and
            $InputObject -isnot [Enum]
        )
        {
            $newInputObject = [Ordered]@{
                PSTypeName=@($inputobject.pstypenames)[0]
            }
            if ('System.Object', 'System.Management.Automation.PSCustomObject' -contains 
                $newInputObject.pstypename) {
                $newInputObject.Remove('PSTypeName')
            } 
            foreach ($prop in $inputObject.psobject.properties) {                
                $newInputObject[$prop.Name] = $prop.Value
            }            
            $inputObject = $newInputObject
        }
        
        $scriptString = ""
        if ($inputObject -is [Collections.IDictionary]) {
            #region Indent            
            $indent = $CurrentDepth * 4
            $scriptString+= 
                if ($Compress) {
                    "@{"
                } else {
                    "@{
"
                }        
            
            #endregion Indent
            #region Include
            $items = $inputObject.GetEnumerator()

            if ($Sort) {
                $items = $items | Sort-Object Key
            }
            

            foreach ($kv in $items) {
                if (-not $Compress) {
                    $scriptString+=" " * $indent
                }
                if ($kv.Key -eq 'keywords') {
                    $null = $null
                }
                $keyString = "$($kv.Key)"
                if ($keyString.IndexOfAny(" _.#-+:;()'!?^@#$%&amp;=|".ToCharArray()) -ne -1) {
                    if ($keyString.IndexOf("'") -ne -1) {
                        $scriptString+="'$($keyString.Replace("'","''"))' = "
                    } else {
                        $scriptString+="'$keyString' = "
                    }                    
                } elseif ($keyString) {
                    $scriptString+="$keyString = "
                }
                                                                
                $value = $kv.Value                
                $value =
                    if ($value -is [string]) {                
                        "'"  + 
                        $value.Replace("'","''").Replace("’", "’’").Replace("‘", "‘‘") +
                        "'"
                    } elseif (
                        $value -is [ScriptBlock] -or $value -is [Management.Automation.Language.Ast]
                    ) {
                        if ($safe) { 
                            "@'" + [Environment]::NewLine +
                            $value
                            [Environment]::NewLine + "'@'"
                        }  else {
                            "{$value}"
                        } 
                    } elseif ($value -is [switch]) {
                        if ($value) { '$true' } else { '$false' }
                    } elseif ($value -is [DateTime]) {
                        "[DateTime]'$($value.ToString("o"))'"
                    } 
                    elseif ($value -is [Timespan]) {                        
                            if ($Safe) { 
                                "'$($value.ToString())'"
                            } else {
                                "[Timespan]'$($value.ToString())'"
                            }
                    } 
                    elseif ($value -is [bool]) {
                        if ($value) { '$true'} else { '$false' }
                    } elseif ($value -and $value.GetType -and (
                        $value.GetType().IsArray -or $value -is [Collections.IList] -or
                        ($value -is [Collections.IEnumerable] -and $value -isnot [Collections.IDictionary])
                    )) {
                        $joiner =
                            if ($Compress) {
                                ','
                            } else {
                                "," + [Environment]::NewLine + (' ' * ($indent + 4))
                            }
                        @(foreach ($v in $value) {
                            if ($v -is [Collections.IDictionary]) {                            
                                &amp; $myScriptBlock -InputObject $v @myParams
                            } elseif ($v -is [ScriptBlock] -or $v -is [Management.Automation.Language.Ast]) {
                                if ($Safe) {

                                } else {
                                    "{$v}"
                                }
                            } elseif ($v -is [Object] -and $v -isnot [string]) {
                                &amp; $myScriptBlock -InputObject $v @myParams
                            } elseif ($v -is [bool] -or $v -is [switch]) {
                                "`$$v"
                            } elseif ($null -ne ($v -as [float])) {
                                $v
                            } else {
                                ("'"  + "$v".Replace("'","''").Replace("’", "’’").Replace("‘", "‘‘") + "'")
                            }
                        }) -join $joiner                                        
                    } elseif ($value -as [Collections.IDictionary[]]) {
                        @(foreach ($v in $value) {
                            &amp; $myScriptBlock $v @myParams
                        }) -join ","                    
                    } elseif ($value -is [Collections.IDictionary]) {
                        "$(&amp; $myScriptBlock $value @myParams)"
                    } elseif ($value -as [Double]) {
                        "$value"
                    } elseif ($value -is [Management.Automation.PSCredential] -and $ExpandCredential) {
                        &amp; $myScriptBlock -InputObject ([Ordered]@{
                                Username = $value.Username
                                Password = $value.GetNetworkCredential().Password
                        }) @myParams
                    } else {
                        $valueString = "'$($value -replace "'", "''")'"
                        if ($valueString[0] -eq "'" -and 
                            $valueString[1] -eq "@" -and 
                            $valueString[2] -eq "{") {
                            &amp; $myScriptBlock -InputObject $value @myParams
                        } else {
                            $valueString
                        }                        
                    }

                $scriptString+=
                    if ($Compress) {
                        "$value;"
                    } else {
                        "$value" + [Environment]::NewLine
                    }                                
            }

            if (-not $Compress) {
                $scriptString += " " * ($CurrentDepth - 1) * 4
            }          
            $scriptString += "}"
            if ($AsPSObject -and -not $Safe) {
                $scriptString = "[PSCustomObject][Ordered]$ScriptString"
            }
            #endregion Include
        }
        elseif ($InputObject -is [string]) {
            $scriptString = "'" + $InputObject.Replace("'", "''") + "'"
        }
        elseif (
            $InputObject.GetType -and $InputObject.GetType().IsPrimitive
        ) {
            $scriptString += "$inputObject"
        }
        elseif ($inputObject -is [Enum]) {
            $scriptString = 
                if ($safe) {
                    "'" + $InputObject.ToString().Replace("'", "''") + "'"
                } else {
                    "[$($InputObject.GetType().FullName -replace '^System\.')]" + 
                    "'" + $InputObject.ToString().Replace("'", "''") + "'"
                }
        }
        elseif (-not $inputObject) {
            $scriptString += '$null'
        }
        
        if ($AsScriptBlock) {
            [ScriptBlock]::Create($scriptString)
        } else {                
            $scriptString
        }
   }

                    </Script>
      </ScriptMethod>
      <ScriptMethod>
        <Name>Format-Heatmap</Name>
        <Script>
                        
    &lt;#
    .SYNOPSIS
        Formats a value as a heatmap
    .DESCRIPTION
        Returns the color used to generate a heatmap for a given value.
    #&gt;
    [Management.Automation.Cmdlet("Format", "Object")]
    [ValidateScript({return $true})]
    param(
    # The value that will be heatmapped.
    [Parameter(ValueFromPipeline)]    
    $InputObject,
    
    # The Heatmap maximum, by default 1gb
    [Parameter(Mandatory)]    
    $HeatMapMax = 1gb,
    
    # The Heatmap middle value, by default 512mb
    $HeatMapMiddle = 512mb,
    
    # The Heatmap minimum value, by default 0
    $HeatMapMin = 0,
    
    # The color for cool.
    # To pass a Hex color as an int, simply replace # with 0x
    # (e.g. 0x00ff00 for green instead of '#00ff00') 
    [int]
    $HeatMapCool =0x05dd00,
    
    # The color for hot.
    # To pass a Hex color as an int, simply replace # with 0x
    # (e.g. 0xff0000 for red instead of '#ff0000') 
    [int]
    $HeatMapHot = 0xef1100
    )

    process {
        # Separate out the segments of the color,
        $coolRedPart = [byte](($HeatMapCool -band 0xff0000) -shr 16) # by bitmasking and then shifting right until it's bytes
        $coolGreenPart = [byte](($HeatMapCool -band 0x00ff00) -shr 8)
        $coolBluePart = [byte]($HeatMapCool -band 0x0000ff)

        $hotRedPart = [byte](($HeatMapHot  -band 0xff0000) -shr 16)
        $hotGreenPart = [byte](($HeatMapHot -band 0x00ff00) -shr 8)
        $hotBluePart = [byte]($HeatMapHot -band 0x0000ff)

        "#{0:x2}{1:x2}{2:x2}" -f @(
        if ($InputObject -le $HeatMapMin) 
        {
            $coolRedPart, $coolGreenPart, $coolBluePart
        }
        elseif ($InputObject -ge $HeatMapMax) 
        {
            $hotRedPart, $hotGreenPart, $hotBluePart
        } else {
            if ($InputObject -le $HeatMapMiddle) 
            {
                $d = 1 - ([double]$InputObject / ($HeatMapMiddle - $HeatMapMin))
                [Byte][Math]::Min(255, $hotRedPart * $d + $coolRedPart)
                [Byte][Math]::Min(255, $hotGreenPart * $d + $coolGreenPart)            
                [Byte][Math]::Min(255, $hotBluePart * $d + $coolBluePart)
            } else
            {
                $d = 1 - ([double]$InputObject / ($HeatMapMax - $HeatMapMiddle))
                [Byte][Math]::Min(255, $coolRedPart * $d + $hotRedPart)
                [Byte][Math]::Min(255, $coolGreenPart * $d + $hotGreenPart)            
                [Byte][Math]::Min(255, $coolBluePart * $d + $hotBluePart)
            }
        })
    }

                    </Script>
      </ScriptMethod>
      <ScriptMethod>
        <Name>Format-JSON</Name>
        <Script>
                        
    &lt;#
    
    .SYNOPSIS    
        Formats objects as JSON    
    .DESCRIPTION    
        Formats an object as JSON.    
        This is a light wrapper around ConvertTo-Json with a few key differences:    
        1. It defaults -Depth to 100 (the maximum)    
        2. It will not encode strings that look like JSON.  Format-JSON can have raw JSON as input without it being converted.    
        3. It allows you to force single values into a list with -AsList    
        4. If there is nothing to convert, it outputs an empty JSON object.    
        Using Format-JSON inside of an EZOut command will pack Format-JSON into your exported .ps1xml.    
    .EXAMPLE    
        Format-JSON -InputObject @("a", "b", "c")    
    .EXAMPLE    
        [Ordered]@{a="b";c="d";e=[Ordered]@{f=@('g')}} | Format-JSON    
    
    #&gt;
            
    [Management.Automation.Cmdlet("Format", "Object")]
    param(
    # If set, will always Format-JSON as a list.    
    [switch]
    $AsList
    )
    dynamicParam {
    $baseCommand = 
        if (-not $script:ConvertToJSON) {
            $script:ConvertToJSON = 
                $executionContext.SessionState.InvokeCommand.GetCommand('ConvertTo-JSON','Cmdlet')
            $script:ConvertToJSON
        } else {
            $script:ConvertToJSON
        }
    $IncludeParameter = @()
    $ExcludeParameter = @()


    $DynamicParameters = [Management.Automation.RuntimeDefinedParameterDictionary]::new()            
    :nextInputParameter foreach ($paramName in ([Management.Automation.CommandMetaData]$baseCommand).Parameters.Keys) {
        if ($ExcludeParameter) {
            foreach ($exclude in $ExcludeParameter) {
                if ($paramName -like $exclude) { continue nextInputParameter}
            }
        }
        if ($IncludeParameter) {
            $shouldInclude = 
                foreach ($include in $IncludeParameter) {
                    if ($paramName -like $include) { $true;break}
                }
            if (-not $shouldInclude) { continue nextInputParameter }
        }
        
        $DynamicParameters.Add($paramName, [Management.Automation.RuntimeDefinedParameter]::new(
            $baseCommand.Parameters[$paramName].Name,
            $baseCommand.Parameters[$paramName].ParameterType,
            $baseCommand.Parameters[$paramName].Attributes
        ))
    }
    $DynamicParameters

    }
        begin {
        $accumulateInput = [Collections.Queue]::new()
        $rawJSON         = [Collections.Queue]::new()
        if (-not $PSBoundParameters['Depth']) {
            $PSBoundParameters['Depth'] = $FormatEnumerationLimit
        }
    
    }
        process {
        if ($_ -is [string] -and $_ -match '^\s{0,}[\[\{"]' -and $_ -match '[\]\}"]\s{0,}$') {
            $rawJSON.Enqueue($_)
        } else {
            $accumulateInput.Enqueue($_)        
        }        
    
    }
    end {

        $joiner = "," + $(
            if (-not $PSBoundParameters["Compress"]) {
                [System.Environment]::NewLine
            }            
        )

        $null = $PSBoundParameters.Remove('AsList')

        if ($accumulateInput.Count) {
            if (-not $PSBoundParameters["Depth"]) {
                $PSBoundParameters["Depth"] = 100
            }
            $PSBoundParameters['InputObject'] = 
                if ($accumulateInput.Count -eq 1) {
                    $accumulateInput[0]
                } else {
                    $accumulateInput.ToArray()
                }
            
            $rawJSON.Enqueue((&amp; $baseCommand @PSBoundParameters))
        }

        if ($rawJSON.Count -gt 1 -or $AsList) {
            "[$($rawJSON.ToArray() -join $joiner)]"
        } elseif ($rawJSON.Count -eq 1) {
            $rawJSON[0]
        } else {
            "{}"
        }
    
    }

                    </Script>
      </ScriptMethod>
      <ScriptMethod>
        <Name>Format-Markdown</Name>
        <Script>
                        
    &lt;#
    .SYNOPSIS
        Formats an object as Markdown
    .DESCRIPTION
        Formats an object as Markdown, with many options to work with
    .EXAMPLE
        Format-Markdown -ScriptBlock {
            Get-Process
        }
    .EXAMPLE
         1..6 | Format-Markdown  -HeadingSize { $_ }
    #&gt;
    [Management.Automation.Cmdlet("Format","Object")]
    [ValidateScript({return $true})]
    param(            
    [Parameter(ValueFromPipeline,ValueFromPipelineByPropertyName)]
    [PSObject]
    $InputObject,
    
    # If set, will treat the -InputObject as a paragraph.
    # This is the default for strings, booleans, numbers, and other primitive types.
    [Parameter(ValueFromPipelineByPropertyName)]
    [switch]
    $MarkdownParagraph,

    # If set, will generate a markdown table.
    [Parameter(ValueFromPipelineByPropertyName)]
    [switch]
    $MarkdownTable,

    # If provided, will align columnns in a markdown table.    
    [Parameter(ValueFromPipelineByPropertyName)]
    [ValidateSet("Left","Right","Center", "")]
    [string[]]
    $MarkdownTableAlignment,

    # An array of properties.  Providing this implies -MarkdownTable
    [Parameter(ValueFromPipelineByPropertyName)]
    [PSObject[]]
    $Property,

    # A heading.
    # If provided without -HeadingSize, -HeadingSize will default to 2.
    # If provided with -InputObject, -Heading will take priority.
    [Parameter(ValueFromPipelineByPropertyName)]    
    [string]
    $Heading,

    # The heading size (1-6)
    # If provided without -Heading, the -InputObject will be considered to be a heading.
    [Parameter(ValueFromPipelineByPropertyName)]
    [ValidateRange(1,6)]
    [int]
    $HeadingSize,

    # If set, will create a link.  The -InputObject will be used as the link content    
    [Parameter(ValueFromPipelineByPropertyName)]
    [Alias('Hyperlink', 'Href')]
    [string]
    $Link,

    # If set, will create an image link.  The -Inputobject will be used as the link content.
    [Parameter(ValueFromPipelineByPropertyName)]
    [string]
    $ImageLink,

    # If set, will generate a bullet point list.
    [Parameter(ValueFromPipelineByPropertyName)]
    [Alias('BulletpointList')]
    [switch]
    $BulletPoint,
    
    # If set, bullet or numbered list items will have a checkbox.
    # Each piped -InputObject will be an additional list item.
    [Parameter(ValueFromPipelineByPropertyName)]
    [switch]
    $Checkbox,

    # If set, bullet or numbered list items will be checked.
    [Parameter(ValueFromPipelineByPropertyName)]
    [switch]
    $Checked,

    # If set, will generate a numbered list.
    # Each piped -InputObject will be an additional list item.
    [Parameter(ValueFromPipelineByPropertyName)]
    [switch]
    $NumberedList,

    # If set, will generate a block quote.
    # Each line of the -InputObject will be block quoted.
    [Parameter(ValueFromPipelineByPropertyName)]
    [switch]
    $BlockQuote,

    # If set, will generate a block quote of a particular depth.
    # Each line of the -InputObject will be block quoted.
    [Parameter(ValueFromPipelineByPropertyName)]
    [ValidateRange(1,3)]
    [int]
    $BlockQuoteDepth,
        
    # If provided, will create a markdown numbered list with this particular item as the number.
    [Parameter(ValueFromPipelineByPropertyName)]
    [int]
    $Number,

    # If set, will generate a horizontal rule.  
    # If other parameters are provided, the horiztonal rule will be placed after.
    [Parameter(ValueFromPipelineByPropertyName)]
    [switch]
    $HorizontalRule,

    # If set, will output the -InputObject as a Markdown code block
    [Parameter(ValueFromPipelineByPropertyName)]
    [switch]
    $Code,

    # If set, will output the -InputObject as a Markdown code block, with a given language
    # If the -InputObject is a ScriptBlock, -CodeLanguage will be set to PowerShell.
    [Parameter(ValueFromPipelineByPropertyName)]
    [string]
    $CodeLanguage,

    # If provided, will output a script block as a Markdown code block.
    [Parameter(ValueFromPipelineByPropertyName)]
    [ScriptBlock]
    $ScriptBlock
    )

    begin {
        $numberedListCounter = 0
        $IsFirst = $true
        filter LinkInput {
            $in = $_
            if ($ImageLink) {
                "![$in]($imageLink)"
            } elseif ($link) {
                "[$in]($link)"
            } else {
                "$in"
            }
        }

        $markdownLines = @()
    }

    process {
        
        if ($ScriptBlock -or $inputObject -is [scriptblock]) {  # If a -ScriptBlock was provided
            $CodeLanguage = 'PowerShell' # use PowerShell as a Code Language.
        }

        # If a -HeadingSize or a -Heading were provided, render a heading.
        if ($HeadingSize -or $Heading) 
        {  
            if (-not $HeadingSize) { $HeadingSize = 2} # If the -HeadingSize was not set, set it to 2.
            $headingContent = "$(if ($Heading) { $Heading} else { $inputObject | LinkInput})"
            $markdownLines += 
                if ($HeadingSize -eq 1) {                
                    $headingContent
                    '=' * [Math]::Max($headingContent.Length, 3)
                }
                elseif ($HeadingSize -eq 2) {
                    $headingContent
                    '-' * [Math]::Max($headingContent.Length, 3)
                }
                else  {
                    ("#"*$HeadingSize) + " $headingContent" # Output the -Heading or the -InputObject.
                }
        }
        # If -Code or -CodeLanguage was provided, render a Markdown code block.
        elseif ($Code -or $CodeLanguage)
        { 
            # If the -InputObject was a [ScriptBlock] or there is a -ScriptBlock 
            if ($InputObject -is [scriptblock] -or $ScriptBlock) {
                $CodeLanguage  = 'PowerShell' # set the code language to PowerShell.
            }
            $markdownLines += (
                '```' + # Start the code fence,
                    $(if ($CodeLanguage) { $CodeLanguage}) + # add the language,
                    [Environment]::newline + # then a newline,
                    $(
                        $codeContent = $(if ($ScriptBlock) { "$scriptBlock" } else { $inputObject | LinkInput})  # then the -ScriptBlock or -InputObject
                        $codeContent
                    ) +
                    [Environment]::newline + # then a newline
                '```' # then close the code fence.
            )
        }
        # If -BulletPoint was passed, render a Bullet Point list.
        elseif ($BulletPoint) 
        { 
            $markdownLines += "*$(if ($Checkbox) { "[$(if ($Checked) {"x"} else {" "})]"}) $($inputObject | LinkInput)"
        }
        # If -NumberedList was passed, render a numbered list.
        elseif ($NumberedList -or $Number) 
        {
            $numberedListCounter++ # Increment the counter
            $markdownLines += "$(if ($number) { $number } else {$numberedListCounter}).$(if ($Checkbox) {" [$(if ($Checked) {"x"} else {" "})]"}) $($inputObject | LinkInput)"
        }
        elseif ($BlockQuote -or $BlockQuoteDepth) {
            if (-not $BlockQuoteDepth) { $BlockQuoteDepth = 1 }
            $markdownLines += ("&gt;" * $BlockQuoteDepth ) + ' ' + (
                "$inputObject" -split '(?&gt;\r\n|\n)' -join (
                    [Environment]::NewLine + ("&gt;" * $BlockQuoteDepth) + ' '
                )
            )
        }
        # Otherwise, we have to determine if -InputObject should be a -MarkdownTable or a -MarkdownParagraph.
        else
        {
            # If the input is a primitive type or a string, it should be a markdown paragraph
            if (($inputObject.GetType -and $inputObject.GetType().IsPrimitive) -or 
                $inputObject -is [string]) {
                $MarkdownParagraph = $true
            }
            # If it is a dictionary, it should be a markdown table.
            elseif ($inputObject -is [Collections.IDictionary]) 
            {
                $MarkdownTable = $true
            }
            # If the input is an array, apply the same logic:
            elseif ($inputObject -is [Object[]] -or $InputObject -is [PSObject[]]) {
                $allPrimitives = 1
                # if the array was all primitives or strings                
                foreach ($in in $InputObject) {
                    $allPrimitives = $allPrimitives -band (
                        ($in.GetType -and $in.GetType().IsPrimitive) -or $in -is [string]
                    )
                }
                if ($allPrimitives) { # output as a paragraph.
                    $MarkdownParagraph = $true
                } else {
                    $MarkdownTable = $true
                }
            }
            # If we're still not sure, output as a table.                     
            else {
                $MarkdownTable = $true
            }
        }

        if ($MarkdownParagraph) {
            # If we're outputting as a paragraph, add the input and link it if needed.
            $markdownLines += $inputObject | LinkInput
        } elseif ($MarkdownTable) {
            # If we're rendering a table, we need to go row-by-row.
            foreach ($in in $InputObject) {
                $propertyList = @(
                    # we first need to get a list of properties.
                    # If there was a -Property parameter provided, use it.
                    if ($Property) {
                        foreach ($prop in $Property) {
                            if ($prop -is [string]) { # Strings in -Property should be taken as property names
                                $prop
                            } elseif ($prop.Name -and $prop.Expression -and $prop.Expression -is [scriptblock]) {
                                # and anything with a name and expression script block will run the expression script block.
                                $_ = $psItem = $in
                                @{name=$prop.Name;Value = . $prop.Expression}
                            }
                        }
                    } 
                    # Otherwise, if the input was a dictionary
                    elseif ($in -is [Collections.IDictionary]) 
                    {
                        foreach ($k in $in.Keys) { # take all keys from the dictionary
                            if ($MyInvocation.MyCommand.Parameters[$k]) { continue } # that are not parameters of this function.
                            $k
                        }                        
                    }
                    # Otherwise, walk over all properties on the object
                    else {
                        foreach ($psProp in $In.psobject.properties) {
                            # and skip any properties that are parameters of this function.
                            if ($psProp.Name -notin $MyInvocation.MyCommand.Parameters.Keys) {
                                $psProp
                            }
                        }
                    }
                )

                # If we're rendering the first row of a table
                if ($IsFirst) {
                    # Create the header
                    $markdownLines +=
                        '|' + (@(foreach ($prop in $propertyList) {
                            if ($prop -is [string]) {
                                $prop
                            } else {
                                $prop.Name
                            }
                        }) -replace ([Environment]::newline), '&lt;br/&gt;' -replace '\|', '\|' -join '|') + '|'
                    # Then create the alignment row.
                    $markdownLines +=
                        '|' + $(
                            $columnNumber =0 
                            @(
                                foreach ($prop in $propertyList) {
                                    $colLength = 
                                        if ($prop -is [string]) {
                                            $prop.Length
                                        } else {
                                            $prop.Name.Length
                                        }
                                    if ($MarkdownTableAlignment) {
                                        if ($MarkdownTableAlignment[$columnNumber] -eq 'Left') {
                                            ':' + ("-" * ([Math]::Max($colLength,2) - 1))
                                        }
                                        elseif ($MarkdownTableAlignment[$columnNumber] -eq 'Right') {
                                            ("-" * ([Math]::Max($colLength,2) - 1)) + ':'
                                        }
                                        elseif ($MarkdownTableAlignment[$columnNumber] -eq 'Center') {
                                            ':' + ("-" * ([Math]::max($colLength, 3) - 2)) + ':'
                                        } else {
                                            "-" * $colLength
                                        }
                                    } else {
                                        "-" * $colLength
                                    }
                                    
                                    $columnNumber++
                                }
                            ) -replace ([Environment]::newline), '&lt;br/&gt;' -replace '\|', '\|' -join '|') + '|'                    
                    $IsFirst = $false
                }
                
                # Now we create the row for this object.

                $markdownLine = '|' + (
                    @(
                        foreach ($prop in $propertyList) {
                            if ($prop -is [string]) {
                                $in.$prop | LinkInput
                            } else {
                                $prop.Value | LinkInput
                            }
                        }
                    ) -replace ([Environment]::newline), '&lt;br/&gt;' -replace '\|', '\|' -join '|') + '|'

                $markdownLines += $markdownLine
            }                                    
        }

            
        if (  # There are a few combinations of parameters that make us want to write the -InputObject as a paragraph:
            ($ScriptBlock -and $inputObject) -or # * If -ScriptBlock and -InputObject were both provided.
            ($Heading -and $inputObject)         # * if -Heading and -InputObject were both provided
        ) {
            $markdownLines += $InputObject | LinkInput
        }


        # If we're going to render a horizontal rule (and -MarkdownTable has not been set)
        if ($HorizontalRule -and -not $MarkdownTable) {
            # add the horizontal rule at the end.
            if ($host.UI.RawUI.BufferSize.Width) {                
                $markdownLines += (([string]$HorizontalRuleCharacter) * ($Host.UI.RawUI.BufferSize.Width - 1))
            } else {
                $markdownLines += "---"
            }                        
        }
    }

    end {
        # Now we need to make one last pass to normalize tables
        if ($markdownLines -match '^\|') { # (that is, if we have tables to normalize).
            $maxColumnSize  = @{} # To normalize the table, we need to track the maximum size per column
            foreach ($ml in $markdownLines) {
                if ($ml -match '\^|') {
                    $columnCount = 0
                    foreach ($tablePart in $ml -split '(?&lt;!\\)\|' -ne '') {
                        if ((-not $maxColumnSize[$columnCount]) -or $maxColumnSize[$columnCount] -lt $tablePart.Length) {
                            $maxColumnSize[$columnCount] = [Math]::Max($tablePart.Length, 2)
                        }
                        $columnCount++
                    }
                }
            }
            # One we know the maximum size per column, walk over each line
            $markdownLines = @(foreach ($ml in $markdownLines) {
                if ($ml -match '\^|') {
                    $columnCount = 0
                    # Recreate the line with the right amount of padding.
                    '|' + (@(foreach ($tablePart in $ml -split '(?&lt;!\\)\|' -ne '') {
                        if ($tablePart -match '^[:\-]+$') {
                            if ($tablePart -match '^\:-{0,}\:$') { # If it's an alignment column, make sure to keep the alignment.
                                if ($maxColumnSize[$columnCount] -gt 2) {
                                    ':' + ('-' * ($maxColumnSize[$columnCount] - 2)) + ':'
                                } else {
                                    '::'
                                }
                            }
                            elseif ($tablePart -match '\:$') {
                                $tablePart.PadLeft($maxColumnSize[$columnCount], '-')
                            } 
                            elseif ($tablePart -match '^\:') {
                                $tablePart.PadRight($maxColumnSize[$columnCount], '-')
                            }
                            else {
                                $tablePart.PadRight($maxColumnSize[$columnCount], '-')
                            }
                        } else {
                            $tablePart.PadRight($maxColumnSize[$columnCount], ' ')
                        }
                        $columnCount++                                            
                    }) -join '|') + '|'
                } else {
                    $ml
                }
            })
        }
        $markdownLines -join [Environment]::NewLine        
    }

                    </Script>
      </ScriptMethod>
      <ScriptMethod>
        <Name>Format-Object</Name>
        <Script>
                        
    &lt;#
    .SYNOPSIS
        Formats an Object
    .DESCRIPTION
        Formats any object, using any number of Format-Object extensions.

        Any of the extensions to Format-Object can be embedded into a FormatXML file.
    .EXAMPLE
        "red" | Format-Object -ForegroundColor "red"
    .EXAMPLE
        1..10 | Format-Object -NumberedList
    .LINK
        Get-EZOutExtension
    .LINK
        Format-RichText
    .LINK
        Format-Markdown
    .LINK
        Format-YAML
    .LINK
        Format-Heatmap
    #&gt;
    param(
    [Parameter(ValueFromPipeline)]
    [PSObject]
    $InputObject
    )

    dynamicParam {
        $myCmdName = $MyInvocation.MyCommand
        $dynamicParams = Get-EZOutExtension -DynamicParameter -NoMandatoryDynamicParameter -ParameterSetName "__AllParameterSets" -CommandName $myCmdName
        $null = $dynamicParams.Remove("InputObject")
        $dynamicParams
    }

    begin {
        # First, we make a copy of our parameters
        $paramCopy = @{} + $PSBoundParameters
        $paramCopy.Remove('InputObject')
        # let's initialize an empty variable to keep any extension validation errors.
        $extensionValidationErrors = $null
        # Then we create a hashtable containing the parameters to Get-EZOutExtension:
        $ezOutExtensionParams = @{
            CommandName   = $MyInvocation.MyCommand      # We want extensions for this command
            CouldRun      = $true
            Parameter     = $paramCopy
            ValidateInput = $host                        # that are valid, given the $host.
        }

        # If -Verbose is -Debug is set, we will want to populate extensionValidationErrors
        if ($VerbosePreference -ne 'silentlyContinue' -or 
            $DebugPreference -ne 'silentlyContinue') {
            $ezOutExtensionParams.ErrorAction   = 'SilentlyContinue'           # We do not want to display errors
            $ezOutExtensionParams.ErrorVariable = 'extensionValidationErrors'  # we want to redirect them into $extensionValidationErrors.
            $ezOutExtensionParams.AllValid      = $true                        # and we want to see that all of the validation attributes are correct.
        } else {
            $ezOutExtensionParams.ErrorAction = 'Ignore'
        }

        # Now we get a list of extensions.
        $formatObjectExtensions = @(Get-EZOutExtension @ezOutExtensionParams | Where-Object { $_.ExtensionParameter.Count})

        # If any of them had errors, and we want to see the -Verbose channel
        if ($extensionValidationErrors -and $VerbosePreference -ne 'silentlyContinue')  {
            foreach ($validationError in $extensionValidationErrors) {
                Write-Verbose "$validationError" # write the validation errors to verbose.
                # It should be noted that there will almost always be validation errors,
                # since most extensions will not apply to a given $GitCommand
            }
        }
        
         # Next we want to create a collection of SteppablePipelines.
        # These allow us to run the begin/process/end blocks of each Extension.
        $steppablePipelines =
            [Collections.ArrayList]::new(@(if ($formatObjectExtensions) {
                foreach ($ext in $formatObjectExtensions) {
                    $extParams = $ext.ExtensionParameter
                    $extCmd = $ext.ExtensionCommand
                    $scriptCmd = {&amp; $extCmd @extParams}
                    $scriptCmd.GetSteppablePipeline()
                }
            }))


        # Next we need to start any steppable pipelines.
        # Each extension can break, continue in it's begin block to indicate it should not be processed.
        $spi = 0
        $spiToRemove = @()
        $beginIsRunning = $false
        # Walk over each steppable pipeline.
        :NextExtension foreach ($steppable in $steppablePipelines) {            
            if ($beginIsRunning) { # If beginIsRunning is set, then the last steppable pipeline continued
                $spiToRemove+=$steppablePipelines[$spi] # so mark it to be removed.
            }
            $beginIsRunning = $true      # Note that beginIsRunning=$false,
            try {
                $steppable.Begin($true) # then try to run begin
            } catch {
                $PSCmdlet.WriteError($_) # Write any exceptions as errors
            }
            $beginIsRunning = $false     # Note that beginIsRunning=$false
            $spi++                       # and increment the index.
        }

        # If this is still true, an extenion used 'break', which signals to stop processing of it any subsequent pipelines.
        if ($beginIsRunning) {         
            $spiToRemove += @(for (; $spi -lt $steppablePipelines.Count; $spi++) {
                $steppablePipelines[$spi]
            })
        }

        # Remove all of the steppable pipelines that signaled they no longer wish to run.
        foreach ($tr in $spiToRemove) {
            $steppablePipelines.Remove($tr)
        }
    }
    
    process {
        $myInv = $MyInvocation
        if (-not $steppablePipelines) {                
            # If we do not have any steppable pipelines, output the input object unchanged.
            $InputObject
        }
        else { 
            # If we have steppable pipelines, then we have to do a similar operation as we did for begin.                
            $spi = 0
            $spiToRemove = @()
            $processIsRunning = $false
            # We have to walk thru each steppable pipeline,
            :NextExtension foreach ($steppable in $steppablePipelines) {
                if ($processIsRunning) {  # if $ProcessIsRunning, the pipeline was skipped with continue.
                    $spiToRemove+=$steppablePipelines[$spi] # and we should add it to the list of pipelines to remove
                }
                $processIsRunning = $true # Set $processIsRunning,
                try {
                    # if ($paramCopy.ContainsKey('InputObject')) { # If InputObject was passed positionally
                    #     $steppable.Process() # run process, using no pipelined input.
                    # } else { # otherwise
                    if ($formatObjectExtensions[$spi]) {
                        $steppable.Process([PSObject]$InputObject) # attempt to run process, using $InputObject as the pipelined input.
                    }
                    # }
                } catch {
                    $err  = $_
                    $PSCmdlet.WriteError($_)    # (catch any exceptions and write them as errors).
                }
                $processIsRunning = $false # Set $processIsRunning to $false for the next step.
            }
            
            
            if ($processIsRunning) {  # If $ProcessIsRunning was true, the extension used break
                # which should signal cancellation of all subsequent extensions.
                $spiToRemove += @(for (; $spi -lt $steppablePipelines.Count; $spi++) {
                    $steppablePipelines[$spi]
                })


                $InputObject # We will also output the inputObject in this case.
            }

            # Remove any steppable pipelines we need to remove.
            foreach ($tr in $spiToRemove) { $steppablePipelines.Remove($tr) }
        }     
    }

    end {
        foreach ($sp in $steppablePipelines) {
            $sp.End()
        }
    }

                    </Script>
      </ScriptMethod>
      <ScriptMethod>
        <Name>Format-RichText</Name>
        <Script>
                        
    &lt;#
    .Synopsis
        Formats the text color of output
    .Description
        Formats the text color of output

        * ForegroundColor
        * BackgroundColor
        * Bold
        * Underline
    .Notes
        Stylized Output works in two contexts at present:
        * Rich consoles (Windows Terminal, PowerShell.exe, Pwsh.exe) (when $host.UI.SupportsVirtualTerminal)
        * Web pages (Based off the presence of a $Request variable, or when $host.UI.SupportsHTML (you must add this property to $host.UI))
    #&gt;
    [Management.Automation.Cmdlet("Format","Object")]
    [ValidateScript({
        $canUseANSI     = $host.UI.SupportsVirtualTerminal
        $canUseHTML     = $Request -or $host.UI.SupportsHTML -or $OutputMode -eq 'HTML'
        if (-not ($canUseANSI -or $canUseHTML)) { return $false}
        return $true
    })]
    [OutputType([string])]
    param(
    # The input object
    [Parameter(ValueFromPipeline)]
    [PSObject]
    $InputObject,
    
    # The foreground color
    [string]$ForegroundColor,

    # The background color
    [string]$BackgroundColor,

    # If set, will render as bold
    [switch]$Bold,

    # If set, will render as italic.
    [Alias('Italics')]
    [switch]$Italic,

    # If set, will render as faint
    [switch]$Faint,

    # If set, will render as hidden text.
    [switch]$Hide,

    # If set, will render as blinking (not supported in all terminals or HTML)
    [switch]$Blink,    

    # If set, will render as strikethru
    [Alias('Strikethrough', 'Crossout')]
    [switch]$Strikethru,

    # If set, will underline text
    [switch]$Underline,

    # If set, will double underline text.
    [switch]$DoubleUnderline,    

    # If set, will invert text
    [switch]$Invert,

    # If provided, will create a hyperlink to a given uri
    [Alias('Hyperlink', 'Href')]
    [uri]
    $Link,

    # If set, will not clear formatting
    [switch]$NoClear,

    # The alignment.  Defaulting to Left.
    # Setting an alignment will pad the remaining space on each line.
    [ValidateSet('Left','Right','Center')]
    [string]
    $Alignment,

    # The length of a line.  By default, the buffer width
    [int]$LineLength = $($host.UI.RawUI.BufferSize.Width)
    )    

    begin {
        $canUseANSI     = $host.UI.SupportsVirtualTerminal
        $canUseHTML     = $Request -or $host.UI.SupportsHTML -or $OutputMode -eq 'HTML'
        $knownStreams = @{
            Output='';Error='BrightRed';Warning='BrightYellow';
            Verbose='BrightCyan';Debug='Yellow';Progress='Cyan';
            Success='BrightGreen';Failure='Red';Default=''}

        $ansiCode = [Regex]::new(@'
        (?&lt;ANSI_Code&gt;
        (?-i)\e                                                                                   # An Escape
        \[                                                                                        # Followed by a bracket
        (?&lt;ParameterBytes&gt;[\d\:\;\&lt;\=\&gt;\?]{0,})                                                   # Followed by zero or more parameter  
        bytes
        (?&lt;IntermediateBytes&gt;[\s\!\"\#\$\%\&amp;\'\(\)\*\+\,\-\.\/]{0,})                              # Followed by zero or more 
        intermediate bytes
        (?&lt;FinalByte&gt;[\@ABCDEFGHIJKLMNOPQRSTUVWXYZ\[\\\]\^_\`abcdefghijklmnopqrstuvwxyz\{\|\}\~]) # Followed by a final byte
        
        )                
'@)
        $esc = [char]0x1b
        $standardColors = 'Black', 'Red', 'Green', 'Yellow', 'Blue','Magenta', 'Cyan', 'White'
        $brightColors   = 'BrightBlack', 'BrightRed', 'BrightGreen', 'BrightYellow', 'BrightBlue','BrightMagenta', 'BrightCyan', 'BrightWhite'

        $allOutput      = @()

        $n =0
        $cssClasses = @()        
        $colorAttributes =         
            @(:nextColor foreach ($hc in $ForegroundColor,$BackgroundColor) {
                $n++
                if (-not $hc) { continue }
                if ($hc[0] -eq $esc) {
                    if ($canUseANSI) { 
                        $hc; continue
                    }
                }
        
                $ansiStartPoint = if ($n -eq 1) { 30 } else { 40 } 
                if ($knownStreams.ContainsKey($hc)) {
                    $i = $brightColors.IndexOf($knownStreams[$hc])
                    if ($canUseHTML) {
                        $cssClasses += $hc
                    } else {
                        if ($i -ge 0 -and $canUseANSI) {
                            '' + $esc + "[1;$($ansiStartPoint + $i)m"
                        } else {
                            $i = $standardColors.IndexOf($knownStreams[$hc])
                            if ($i -ge 0 -and $canUseANSI) {
                                '' + $esc + "[1;$($ansiStartPoint + $i)m"
                            } elseif ($i -le 0 -and $canUseANSI) {                        
                                '' + $esc + "[$($ansistartpoint + 8):5m"
                            }
                        }
                    }
                    continue nextColor
                }
                elseif ($standardColors -contains $hc) {
                    for ($i = 0; $i -lt $standardColors.Count;$i++) {
                        if ($standardColors[$i] -eq $hc) {
                            if ($canUseANSI -and -not $canUseHTML) {
                                '' + $esc + "[$($ansiStartPoint + $i)m"
                            } else {
                                $cssClasses += $standardColors[$i]
                            }
                            continue nextColor
                        }
                    }
                } elseif ($brightColors -contains $hc) {
                    for ($i = 0; $i -lt $brightColors.Count;$i++) {
                        if ($brightColors[$i] -eq $hc) {
                            if ($canUseANSI -and -not $canUseHTML) {
                                '' + $esc + "[1;$($ansiStartPoint + $i)m"
                            } else {
                                $cssClasses += $standardColors[$i]
                            }
                            continue nextColor
                        }
                    }
                }                
                elseif ($psStyle -and $psStyle.Formatting.$hc -and 
                    $psStyle.Formatting.$hc -match '^\e') {
                    if ($canUseANSI -and -not $canUseHTML) {
                        $psStyle.Formatting.$hc
                    } else {
                        $cssClasses += "formatting-$hc"
                    }
                }
                elseif (-not $n -and $psStyle -and $psStyle.Foreground.$hc -and 
                    $psStyle.Foreground.$hc -match '^\e' ) {
                    if ($canUseANSI -and -not $canUseHTML) {
                        $psStyle.Foreground.$hc
                    } else {
                        $cssClasses += "foreground-$hc"
                    }                   
                }
                elseif ($n -and $psStyle -and $psStyle.Background.$hc -and
                    $psStyle.Background.$hc -match '^\e') {
                    if ($canUseANSI -and -not $canUseHTML) {
                        $psStyle.Background.$hc
                    } else {
                        $cssClasses += "background-$hc"
                    }                    
                }

        
        
                if ($hc -and $hc -notmatch '^[\#\e]') {
                    $placesToLook=
                        @(if ($hc.Contains('.')) {
                            $module, $setting = $hc -split '\.', 2
                            $theModule = Get-Module $module
                            $theModule.PrivateData.Color,
                                $theModule.PrivateData.Colors,
                                $theModule.PrivateData.Colour,
                                $theModule.PrivateData.Colours,
                                $theModule.PrivateData.EZOut,
                                $global:PSColors,
                                $global:PSColours
                        } else {
                            $setting = $hc
                            $moduleColorSetting = $theModule.PrivateData.PSColors.$setting
                        })
        
                    foreach ($place in $placesToLook) {
                        if (-not $place) { continue }
                        foreach ($propName in $setting -split '\.') {
                            $place = $place.$propName
                            if (-not $place) { break }
                        }
                        if ($place -and "$place".StartsWith('#') -and 4,7 -contains "$place".Length) {
                            $hc = $place
                            continue
                        }
                    }
                    if (-not $hc.StartsWith -or -not $hc.StartsWith('#')) {
                        continue
                    }
                }
                $r,$g,$b = if ($hc.Length -eq 7) {
                    [int]::Parse($hc[1..2]-join'', 'HexNumber')
                    [int]::Parse($hc[3..4]-join '', 'HexNumber')
                    [int]::Parse($hc[5..6] -join'', 'HexNumber')
                }elseif ($hc.Length -eq 4) {
                    [int]::Parse($hc[1], 'HexNumber') * 16
                    [int]::Parse($hc[2], 'HexNumber') * 16
                    [int]::Parse($hc[3], 'HexNumber') * 16
                }
        
                if ($canUseHTML) {
                    if ($n -eq 1) { "color:$hc" }
                    elseif ($n -eq 2) { "background-color:$hc"} 
                }
                elseif ($canUseANSI) {
                    if ($n -eq 1) { $esc+"[38;2;$r;$g;${b}m" }
                    elseif ($n -eq 2) { $esc+"[48;2;$r;$g;${b}m" }
                }
                
            })
        
        $styleAttributes = @() + $colorAttributes
        
        $styleAttributes += @(
            if ($Bold) {
                if ($canUseHTML) {"font-weight:bold"}
                elseif ($canUseANSI) { '' + $esc + "[1m" }
            }
            if ($Faint) {
                if ($canUseHTML) { "opacity:.5" }
                elseif ($canUseANSI) { '' + $esc + "[2m" }
            }
            if ($Italic) {                
                if ($canUseHTML) { "font-weight:bold" }
                elseif ($canUseANSI)  {'' + $esc + "[3m" }
            }
            
            if ($Underline -and -not $doubleUnderline) {             
                if ($canUseHTML) { "text-decoration:underline"} 
                elseif ($canUseANSI) {'' +$esc + "[4m" }
            }

            if ($Blink) {             
                if ($canUseANSI) { '' +$esc + "[5m" }
            }

            if ($invert) {
                if ($canUseHTML) {"filter:invert(100%)"}
                elseif ($canUseANSI) { '' + $esc + "[7m"}
            }

            if ($hide) {
                if ($canUseHTML) {"opacity:0"}
                elseif ($canUseANSI) { '' + $esc + "[8m"}
            }
            
            if ($Strikethru) {             
                if ($canUseHTML) {"text-decoration: line-through"}
                elseif ($canUseANSI) { '' +$esc + "[9m" }
            }
            
            if ($DoubleUnderline) {
                if ($canUseHTML) { "border-bottom: 3px double;"}
                elseif ($canUseANSI) {'' +$esc + "[21m" }
            }

            if ($Alignment -and $canUseHTML) {
                "display:block;text-align:$($Alignment.ToLower())"
            }

            if ($Link) {
                if ($canUseHTML) { 
                    # Hyperlinks need to be a nested element
                    # so we will not add it to style attributes for HTML
                }
                elseif ($canUseANSI) {
                    # For ANSI,
                    '' + $esc + ']8;;' + $Link + $esc + '\'   
                }
            }
            
        )
        
        $header =
            if ($canUseHTML) {        
                "&lt;span$(
                    if ($styleAttributes) { " style='$($styleAttributes -join ';')'"}
                )$(
                    if ($cssClasses) { " class='$($cssClasses -join ' ')'"}
                )&gt;" + $(
                    if ($Link) {
                        "&lt;a href='$link'&gt;"
                    }
                )
            } elseif ($canUseANSI) {
                $styleAttributes -join ''
            }
    }

    process {
        $inputObjectAsString =
            "$(if ($inputObject) { $inputObject | Out-String})".Trim()

        $inputObjectAsString = 
            if ($Alignment -and -not $canUseHTML) {
                (@(foreach ($inputObjectLine in ($inputObjectAsString -split '(?&gt;\r\n|\n)')) {
                    $inputObjectLength = $ansiCode.Replace($inputObjectLine, '').Length
                    if ($inputObjectLength -lt $LineLength) {
                        if ($Alignment -eq 'Left') {
                            $inputObjectLine
                        } elseif ($Alignment -eq 'Right') {
                            (' ' * ($LineLength - $inputObjectLength)) + $inputObjectLine                            
                        } else {
                            $half = ($LineLength - $inputObjectLength)/2
                            (' ' * [Math]::Floor($half)) + $inputObjectLine +
                            (' ' * [Math]::Ceiling($half))
                        }
                    }
                    else {
                        $inputObjectLine
                    }
                }) -join [Environment]::NewLine) + [Environment]::newline
            } else {
                $inputObjectAsString
            }

        $allOutput +=
            if ($header) {
                "$header" + $inputObjectAsString
            }
            elseif ($inputObject) {
                $inputObjectAsString
            }
    }

    end {
        
        if (-not $NoClear) {
            $allOutput += 
                if ($canUseHTML) {
                    if ($Link) {
                        "&lt;/a&gt;"
                    }
                    "&lt;/span&gt;"
                }
                elseif ($canUseANSI) {
                    if ($Bold -or $Faint -or $colorAttributes -match '\[1;') {
                        "$esc[22m"
                    }
                    if ($Italic) {
                        "$esc[23m"
                    }
                    if ($Underline -or $doubleUnderline) {
                        "$esc[24m"
                    }
                    if ($Blink) {
                        "$esc[25m"
                    }                
                    if ($Invert) {
                        "$esc[27m"
                    }
                    if ($hide) {
                        "$esc[28m"
                    }
                    if ($Strikethru) {
                        "$esc[29m"
                    }
                    if ($ForegroundColor) {
                        "$esc[39m"
                    }
                    if ($BackgroundColor) {
                        "$esc[49m"
                    }

                    if ($Link) {
                        "$esc]8;;$esc\"
                    }
                
                    if (-not ($Underline -or $Bold -or $Invert -or $ForegroundColor -or $BackgroundColor)) {
                        '' + $esc + '[0m'
                    }
                }
        }

        $allOutput -join ''
    }

                    </Script>
      </ScriptMethod>
      <ScriptMethod>
        <Name>Format-YAML</Name>
        <Script>
                        
    &lt;#
    .SYNOPSIS
        Formats objects as YAML
    .DESCRIPTION
        Formats an object as YAML.
    .EXAMPLE
        Format-Yaml -InputObject @("a", "b", "c")
    .EXAMPLE
        @{a="b";c="d";e=@{f=@('g')}} | Format-Yaml
    #&gt;
    [Management.Automation.Cmdlet("Format","Object")]
    [ValidateScript({return $true})]
    param(
    # The InputObject.
    [Parameter(ValueFromPipeline)]
    [PSObject]
    $InputObject,

    # If set, will make a YAML header by adding a YAML Document tag above and below output.
    [Alias('YAMLDocument')]
    [switch]
    $YamlHeader,

    [int]
    $Indent = 0,

    # The maximum depth of objects to include.
    # Beyond this depth, an empty string will be returned.    
    [int]
    $Depth
    )

    begin {
        if (-not $Depth) { $depth = $FormatEnumerationLimit }
        $toYaml = {
            param(
            [Parameter(ValueFromPipeline,Position=0)]$Object,
            [Object]$Parent,
            [Object]$GrandParent,
            [int]$Indent = 0)
            
            begin { $n = 0; $mySelf = $myInvocation.MyCommand.ScriptBlock }
            process {
                $n++
                if ($Object -eq $null) { return }

                if ($depth) {
                    $myDepth = $indent / 2
                    if ($myDepth -gt $depth) {
                        return ''
                    }
                }
            
                if ($Parent -and $Parent -is [Collections.IList]) {
                    if ($Parent.IndexOf($Object) -gt 0) { ' ' * $Indent }
                    '- '
                }
            
                #region Primitives
                if ( $Object -is [string] ) { # If it's a string
                    if ($object -match '\n') { # see if it's a multline string.
                        "|" # If it is, emit the multiline indicator
                        $indent +=2
                        foreach ($l in $object -split '(?&gt;\r\n|\n)') { # and emit each line indented
                            [Environment]::NewLine
                            ' ' * $indent
                            $l
                        }
                        $indent -=2
                    } elseif ("$object".Contains('*')) {
                        "'$($Object -replace "'","''")'"
                    } else {
                        $object
                    }
            
                    if ($Parent -is [Collections.IList]) { # If the parent object was a list
                        [Environment]::NewLine # emit a newline.
                    }
                    return # Once the string has been emitted, return.
                }
                if ( $Object.GetType().IsPrimitive ) { # If it is a primitive type
                    "$Object".ToLower()  # Emit it in lowercase.
                    if ($Parent -is [Collections.IList]) {
                        [Environment]::NewLine
                    }
                    return
                }
                #endregion Primitives
            
                #region KVP
                if ( $Object -is [Collections.DictionaryEntry] -or $object -is [Management.Automation.PSPropertyInfo]) {
                    if ($Parent -isnot [Collections.IList] -and
                        ($GrandParent -isnot [Collections.IList] -or $n -gt 1)) {
                        [Environment]::NewLine + (" " * $Indent)
                    }
                    if ($object.Key -and $Object.Key -is [string]) {
                        $Object.Key +": "
                    } elseif ($object.Name -and $object.Name -is [string]) {
                        $Object.Name +": "
                    }
                }
            
                if ( $Object -is [Collections.DictionaryEntry] -or $Object -is [Management.Automation.PSPropertyInfo]) {
                    &amp; $mySelf -Object $Object.Value -Parent $Object -GrandParent $parent -Indent $Indent
                    return
                }
                #endregion KVP
            
            
                #region Nested
                if ($parent -and ($Object -is [Collections.IDictionary] -or $Object  -is [PSObject])) {
                    $Indent += 2
                } 
                elseif ($object -is [Collections.IList]) {
                    $allPrimitive = 1
                    foreach ($Obj in $Object) { 
                        $allPrimitive = $allPrimitive -band (
                            $Obj -is [string] -or 
                            $obj.GetType().IsPrimitive
                        ) 
                    }
                    if ($parent -and -not $allPrimitive) {
                        $Indent += 2
                    }
                }
            
            
                if ( $Object -is [Collections.IDictionary] ) {
                    $Object.GetEnumerator() |
                        &amp; $mySelf -Parent $Object -GrandParent $Parent -Indent $Indent
                } elseif ($Object -is [Collections.IList]) {
            
                    [Environment]::NewLine + (' ' * $Indent)
            
                    $Object |
                        &amp; $mySelf -Parent $Object -GrandParent $Parent -Indent $Indent
            
                } 
                elseif ($object -is [enum]) {
                    $object.ToString()
                }
                elseif ($Object.PSObject.Properties) {
                    $Object.psobject.properties |
                        &amp; $mySelf -Parent $Object -GrandParent $Parent -Indent $Indent
                }
            
                if ($Object -is [Collections.IDictionary] -or $Object  -is [PSCustomObject] -or $Object -is [Collections.IList]) {
                    if ($Parent -is [Collections.IList]) { [Environment]::NewLine }
                    $Indent -= 2;
                }
                #endregion Nested
            }                
        }
        function IndentString([string]$String,[int]$Indent) {
            @(foreach ($line in @($String -split '(?&gt;\r\n|\n)')) {
                (' ' * $indent) + $line 
            }) -join [Environment]::NewLine
        }
        $inputWasNotPiped = $PSBoundParameters.InputObject -as [bool]
        $allInputObjects  = @()
    }

    process {
        if ($inputWasNotPiped) {
            IndentString ('' + $(if ($YamlHeader) { '---' + [Environment]::NewLine })  + (
                (&amp; $toYaml -object $inputObject) -join '' -replace 
                    "$([Environment]::NewLine * 2)", [Environment]::NewLine
            ) + $(if ($YamlHeader) { [Environment]::NewLine  + '---'})) -Indent $Indent
        } else {
            $allInputObjects += $inputObject
        }
    }

    end {
        if (-not $allInputObjects) { return }
        if ($allInputObjects.Length -eq 1) {
            IndentString ('' + $(if ($YamlHeader) { '---' + [Environment]::NewLine}) + (
                (&amp; $toYaml -object $inputObject) -join '' -replace 
                    "$([Environment]::NewLine * 2)", [Environment]::NewLine
            ) + $(if ($YamlHeader) { [Environment]::NewLine  + '---'})) -Indent $Indent
        } else {
            IndentString ('' + $(if ($YamlHeader) { '---' + [Environment]::NewLine})  + (
                (&amp; $toYaml -object $allInputObjects) -join '' -replace 
                    "$([Environment]::NewLine * 2)", [Environment]::NewLine
            ) + $(if ($YamlHeader) { [Environment]::NewLine  + '---'})) -Indent $Indent
        }
    }

                    </Script>
      </ScriptMethod>
      <ScriptMethod>
        <Name>Get-EZOutExtension</Name>
        <Script>
                        
    &lt;#
    .Synopsis
        Gets Extensions
    .Description
        Gets Extensions.

        EZOutExtensions can be found in:

        * Any module that includes -EZOutExtensionModuleName in it's tags.
        * The directory specified in -EZOutExtensionPath
        * Commands that meet the naming criteria
    .Example
        Get-EZOutExtension
    #&gt;
    [OutputType('Extension')]
    [Diagnostics.CodeAnalysis.SuppressMessageAttribute("PSReviewUnusedParameter", "", Justification="PSScriptAnalyzer cannot handle nested scoping")]
    [Diagnostics.CodeAnalysis.SuppressMessageAttribute("PSAvoidAssignmentToAutomaticVariable", "", Justification="Desired for scenario")]
    param(
    # If provided, will look beneath a specific path for extensions.
    [Parameter(ValueFromPipelineByPropertyName)]
    [Alias('Fullname')]
    [string]
    $ExtensionPath,

    # If set, will clear caches of extensions, forcing a refresh.
    [switch]
    $Force,

    # If provided, will get EZOutExtensions that extend a given command
    [Parameter(ValueFromPipelineByPropertyName)]
    [Alias('ThatExtends', 'For')]
    [string[]]
    $CommandName,

    &lt;#
    
    The name of an extension.
    By default, this will match any extension command whose name, displayname, or aliases exactly match the name.

    If the extension has an Alias with a regular expression literal (```'/Expression/'```) then the -EZOutExtensionName will be valid if that regular expression matches.
    #&gt;
    [Parameter(ValueFromPipelineByPropertyName)]
    [ValidateNotNullOrEmpty()]
    [string[]]
    $ExtensionName,
    
    &lt;#

    If provided, will treat -EZOutExtensionName as a wildcard.
    This will return any extension whose name, displayname, or aliases are like the -EZOutExtensionName.

    If the extension has an Alias with a regular expression literal (```'/Expression/'```) then the -EZOutExtensionName will be valid if that regular expression matches.
    #&gt;
    [Parameter(ValueFromPipelineByPropertyName)]
    [switch]
    $Like,

    &lt;#
    
    If provided, will treat -EZOutExtensionName as a regular expression.
    This will return any extension whose name, displayname, or aliases match the -EZOutExtensionName.
    
    If the extension has an Alias with a regular expression literal (```'/Expression/'```) then the -EZOutExtensionName will be valid if that regular expression matches.
    #&gt;
    [Parameter(ValueFromPipelineByPropertyName)]
    [switch]
    $Match,

    # If set, will return the dynamic parameters object of all the EZOutExtensions for a given command.
    [Parameter(ValueFromPipelineByPropertyName)]
    [switch]
    $DynamicParameter,

    # If set, will return if the extension could run.
    [Parameter(ValueFromPipelineByPropertyName)]
    [Alias('CanRun')]
    [switch]
    $CouldRun,

    # If set, will return if the extension could accept this input from the pipeline.
    [Alias('CanPipe')]
    [PSObject]
    $CouldPipe,

    # If set, will run the extension.  If -Stream is passed, results will be directly returned.
    # By default, extension results are wrapped in a return object.
    [Parameter(ValueFromPipelineByPropertyName)]
    [switch]
    $Run,

    # If set, will stream output from running the extension.
    # By default, extension results are wrapped in a return object.
    [Parameter(ValueFromPipelineByPropertyName)]
    [switch]
    $Stream,

    # If set, will return the dynamic parameters of all EZOutExtensions for a given command, using the provided DynamicParameterSetName.
    # Implies -DynamicParameter.
    [Parameter(ValueFromPipelineByPropertyName)]
    [string]
    $DynamicParameterSetName,


    # If provided, will return the dynamic parameters of all EZOutExtensions for a given command, with all positional parameters offset.
    # Implies -DynamicParameter.
    [Parameter(ValueFromPipelineByPropertyName)]
    [int]
    $DynamicParameterPositionOffset = 0,

    # If set, will return the dynamic parameters of all EZOutExtensions for a given command, with all mandatory parameters marked as optional.
    # Implies -DynamicParameter.  Does not actually prevent the parameter from being Mandatory on the Extension.
    [Parameter(ValueFromPipelineByPropertyName)]
    [Alias('NoMandatoryDynamicParameters')]
    [switch]
    $NoMandatoryDynamicParameter,

    # If set, will require a [Runtime.CompilerServices.Extension()] attribute to be considered an extension.
    [Parameter(ValueFromPipelineByPropertyName)]
    [switch]
    $RequireExtensionAttribute,

    # If set, will validate this input against [ValidateScript], [ValidatePattern], [ValidateSet], and [ValidateRange] attributes found on an extension.
    [Parameter(ValueFromPipelineByPropertyName)]
    [PSObject]
    $ValidateInput,

    # If set, will validate this input against all [ValidateScript], [ValidatePattern], [ValidateSet], and [ValidateRange] attributes found on an extension.
    # By default, if any validation attribute returned true, the extension is considered validated.
    [switch]
    $AllValid,

    # The name of the parameter set.  This is used by -CouldRun and -Run to enforce a single specific parameter set.
    [Parameter(ValueFromPipelineByPropertyName)]
    [string]
    $ParameterSetName,

    # The parameters to the extension.  Only used when determining if the extension -CouldRun.
    [Parameter(ValueFromPipelineByPropertyName)]
    [Collections.IDictionary]
    [Alias('Parameters','ExtensionParameter','ExtensionParameters')]
    $Parameter = [Ordered]@{},

    # If set, will output a steppable pipeline for the extension.
    # Steppable pipelines allow you to control how begin, process, and end are executed in an extension.
    # This allows for the execution of more than one extension at a time.
    [switch]
    $SteppablePipeline,

    # If set, will output the help for the extensions
    [switch]
    $Help
    )

    begin {
        $ExtensionPattern = '(?&gt;extension|ext|ex|x)\.ps1$'
        $ExtensionModule = 'EZOut'
        $ExtensionModuleAlias = 'ez'
        $ExtensionTypeName = 'EZOut.Extension'
        #region Define Inner Functions
        function WhereExtends {
            param(
            [Parameter(Position=0)]
            [string[]]
            $Command,

            [Parameter(ValueFromPipeline)]
            [PSObject]
            $ExtensionCommand
            )

            process {
                if ($ExtensionName) {
                    $ExtensionCommandAliases = @($ExtensionCommand.Attributes.AliasNames)
                    $ExtensionCommandAliasRegexes = @($ExtensionCommandAliases -match '^/' -match '/$')
                    if ($ExtensionCommandAliasRegexes) {
                        $ExtensionCommandAliases = @($ExtensionCommandAliases -notmatch '^/' -match '/$')
                    }
                    :CheckExtensionName do {
                        foreach ($exn in $ExtensionName) {
                            if ($like) {
                                if (($extensionCommand -like $exn) -or
                                    ($extensionCommand.DisplayName -like $exn) -or
                                    ($ExtensionCommandAliases -like $exn)) { break CheckExtensionName }
                            }
                            elseif ($match) {
                                if (($ExtensionCommand -match $exn) -or
                                    ($extensionCommand.DisplayName -match $exn) -or
                                    ($ExtensionCommandAliases -match $exn)) { break CheckExtensionName }
                            }
                            elseif (($ExtensionCommand -eq $exn) -or
                                ($ExtensionCommand.DisplayName -eq $exn) -or
                                ($ExtensionCommandAliases -eq $exn)) { break CheckExtensionName }
                            elseif ($ExtensionCommandAliasRegexes) {
                                foreach ($extensionAliasRegex in $ExtensionCommandAliasRegexes) {                            
                                    $extensionAliasRegex = [Regex]::New($extensionAliasRegex -replace '^/' -replace '/$', 'IgnoreCase,IgnorePatternWhitespace')
                                    if ($extensionAliasRegex -and $extensionAliasRegex.IsMatch($exn)) {
                                        break CheckExtensionName
                                    }
                                }
                            }
                        }
                        

                        return
                    } while ($false)
                }
                if ($Command -and $ExtensionCommand.Extends -contains $command) {
                    $commandExtended = $ext
                    return $ExtensionCommand
                }
                elseif (-not $command) {
                    return $ExtensionCommand
                }
            }
        }
        function ConvertToExtension($toExtension) {
            
            process {
                
            $in = if ($toExtension) {
                $toExtension
            } else { $_ }
                 
            $extCmd =
                if ($in -is [Management.Automation.CommandInfo]) {
                    $in
                }
                elseif ($in -is [IO.FileInfo]) {
                    if ($in.LastWriteTime -gt $script:EZOutExtensionsFileTimes[$in.Fullname]) {
                        $script:EZOutExtensionsFileTimes[$in.Fullname] = $in.LastWriteTime
                        $script:EZOutExtensionsFromFiles[$in.Fullname] = 
                            $ExecutionContext.SessionState.InvokeCommand.GetCommand($in.fullname, 'ExternalScript,Application')
                        $script:EZOutExtensionsFromFiles[$in.Fullname]
                    } elseif ($script:EZOutExtensionsFromFiles[$in.Fullname])  {
                        return $script:EZOutExtensionsFromFiles[$in.Fullname]
                    }                    
                }
                else {
                    $ExecutionContext.SessionState.InvokeCommand.GetCommand($in, 'Alias,Function,ExternalScript,Application')
                }

            $extMethods    = $extCmd.PSObject.Methods
            $extProperties = $extCmd.PSObject.Properties

            #region .GetExtendedCommands
            if (-not $extMethods['GetExtendedCommands']) {
                $extMethods.Add([psscriptmethod]::new('GetExtendedCommands', {
                param([Management.Automation.CommandInfo[]]$CommandList)
                $extendedCommandNames = @(
                    foreach ($attr in $this.ScriptBlock.Attributes) {
                        if ($attr -isnot [Management.Automation.CmdletAttribute]) { continue }
                        (
                            ($attr.VerbName -replace '\s') + '-' + ($attr.NounName -replace '\s')
                        ) -replace '^\-' -replace '\-$'                        
                    }
                )
                if (-not $extendedCommandNames) {
                    $this.PSObject.Properties.Add([psnoteproperty]::new('.Extends', @()), $true)
                    $this.PSObject.Properties.Add([psnoteproperty]::new('.ExtensionCommands', @()), $true)                    
                    return    
                }
                if (-not $CommandList) {
                    $commandList = $ExecutionContext.SessionState.InvokeCommand.GetCommands('*','Function,Alias,Cmdlet', $true)
                }
                $extends = @{}
                :nextCommand foreach ($loadedCmd in $commandList) {
                    foreach ($extensionCommandName in $extendedCommandNames) {
                        if ($extensionCommandName -and $loadedCmd.Name -match $extensionCommandName) {
                            $loadedCmd
                            $extends[$loadedCmd.Name] = $loadedCmd
                            continue nextCommand
                        }
                    }
                }

                if (-not $extends.Count) {
                    $extends = $null
                }
                $this.PSObject.Properties.Add([psnoteproperty]::new('.Extends', @($extends.Keys)), $true)
                $this.PSObject.Properties.Add([psnoteproperty]::new('.ExtensionCommands', @($extends.Values)), $true)                
                }), $true)
            }
            #endregion .GetExtendedCommands

            #region .Extends
            if (-not $extProperties['Extends']) {
                $extProperties.Add([psscriptproperty]::new('Extends', {
                    if (-not $this.'.Extends') {
                        $this.GetExtendedCommands(
                            $ExecutionContext.SessionState.InvokeCommand.GetCommands('*','Function,Alias,Cmdlet', $true)
                        )
                    }
                    return $this.'.Extends'
                }),$true)
            }
            #endregion .Extends

            #region .ExtensionCommands
            if (-not $extProperties['ExtensionCommands']) {
                $extProperties.Add([psscriptproperty]::new('ExtensionCommands', {
                    if (-not $this.'.ExtensionCommands') {
                        $this.GetExtendedCommands(
                            $ExecutionContext.SessionState.InvokeCommand.GetCommands('*','Function,Alias,Cmdlet', $true)
                        )
                    }
                    return $this.'.ExtensionCommands'
                }), $true)
            }
            #endregion .ExtensionCommands

            $inheritanceLevel = [ComponentModel.InheritanceLevel]::Inherited

            #region .BlockComments
            if(-not $extProperties['BlockComments']) {
                $extProperties.Add([psscriptproperty]::New('BlockComments', {
                    [Regex]::New("                   
                    \&lt;\# # The opening tag
                    (?&lt;Block&gt; 
                        (?:.|\s)+?(?=\z|\#&gt;) # anything until the closing tag
                    )
                    \#\&gt; # the closing tag
                    ", 'IgnoreCase,IgnorePatternWhitespace', '00:00:01').Matches($this.ScriptBlock)
                }), $true)
            }
            #endregion .BlockComments

            #region .GetHelpField
            if (-not $extMethods['GetHelpField']) {
                $extMethods.Add([psscriptmethod]::New('GetHelpField', {
                    param([Parameter(Mandatory)]$Field)
                    $fieldNames = 'synopsis','description','link','example','inputs', 'outputs', 'parameter', 'notes'
                    foreach ($block in $this.BlockComments) {                
                        foreach ($match in [Regex]::new("
                            \.(?&lt;Field&gt;$Field)                   # Field Start
                            [\s-[\r\n]]{0,}                      # Optional Whitespace
                            [\r\n]+                              # newline
                            (?&lt;Content&gt;(?:.|\s)+?(?=
                            (
                                [\r\n]{0,}\s{0,}\.(?&gt;$($fieldNames -join '|'))|
                                \#\&gt;|
                                \z
                            ))) # Anything until the next .field or end of the comment block
                            ", 'IgnoreCase,IgnorePatternWhitespace', [Timespan]::FromSeconds(1)).Matches(
                                $block.Value
                            )) {                        
                            $match.Groups["Content"].Value -replace '[\s\r\n]+$'
                        }                    
                    }
                }), $true)
            }
            #endregion .GetHelpField

            #region .InheritanceLevel
            if (-not $extProperties['InheritanceLevel']) {
                $extProperties.Add([PSNoteProperty]::new('InheritanceLevel', $inheritanceLevel), $true)
            }
            #endregion .InheritanceLevel

            #region .DisplayName
            if (-not $extProperties['DisplayName']) {
                $extProperties.Add([PSScriptProperty]::new(
                    'DisplayName', {
                        if ($this.'.DisplayName') {
                            return $this.'.DisplayName'
                        }
                        if ($this.ScriptBlock.Attributes) {
                            foreach ($attr in $this.ScriptBlock.Attributes) {
                                if ($attr -is [ComponentModel.DisplayNameAttribute]) {
                                    $this | Add-Member NoteProperty '.DisplayName' $attr.DisplayName -Force
                                    return $attr.DisplayName
                                }
                            }
                        }
                        $this | Add-Member NoteProperty '.DisplayName' $this.Name
                        return $this.Name
                    }, {
                        $this | Add-Member NoteProperty '.DisplayName' $args -Force
                    }
                ), $true)

                $extProperties.Add([PSNoteProperty]::new(
                    '.DisplayName', "$($extCmd.Name -replace $extensionFullRegex)"
                ), $true)
            }            
            #endregion .DisplayName
            
            #region .Attributes
            if (-not $extProperties['Attributes']) {
                $extProperties.Add([PSScriptProperty]::new(
                    'Attributes', {$this.ScriptBlock.Attributes}
                ), $true)
            }
            #endregion .Attributes

            #region .Category
            if (-not $extProperties['Category']) {
                $extProperties.Add([PSScriptProperty]::new(
                    'Category', {
                        foreach ($attr in $this.ScriptBlock.Attributes) {
                            if ($attr -is [Reflection.AssemblyMetaDataAttribute] -and
                                $attr.Key -eq 'Category') {
                                $attr.Value
                            }
                            elseif ($attr -is [ComponentModel.CategoryAttribute]) {
                                $attr.Category
                            }
                        }
                        
                    }
                ), $true)
            }
            #endregion .Category

            #region .Rank
            if (-not $extProperties['Rank']) {
                $extProperties.Add([PSScriptProperty]::new(
                    'Rank', {
                        foreach ($attr in $this.ScriptBlock.Attributes) {
                            if ($attr -is [Reflection.AssemblyMetaDataAttribute] -and
                                $attr.Key -in 'Order', 'Rank') {
                                return $attr.Value -as [int]
                            }
                        }
                        return 0
                    }
                ), $true)
            }
            #endregion .Rank
            
            #region .Metadata
            if (-not $extProperties['Metadata']) {
                $extProperties.Add([psscriptproperty]::new(
                    'Metadata', {
                        $Metadata = [Ordered]@{}
                        foreach ($attr in $this.ScriptBlock.Attributes) {
                            if ($attr -is [Reflection.AssemblyMetaDataAttribute]) {
                                if ($Metadata[$attr.Key]) {
                                    $Metadata[$attr.Key] = @($Metadata[$attr.Key]) + $attr.Value
                                } else {
                                    $Metadata[$attr.Key] = $attr.Value
                                }                            
                            }
                        }
                        return $Metadata
                    }
                ), $true)
            }
            #endregion .Metadata

            #region .Description
            if (-not $extProperties['Description']) {
                $extProperties.Add([PSScriptProperty]::new(
                    'Description', { @($this.GetHelpField("Description"))[0] -replace '^\s+' }
                ), $true)
            }
            #endregion .Description

            #region .Synopsis
            if (-not $extProperties['Synopsis']) {
            $extProperties.Add([PSScriptProperty]::new(
                'Synopsis', { @($this.GetHelpField("Synopsis"))[0] -replace '^\s+' }), $true)
            }
            #endregion .Synopsis

            #region .Examples
            if (-not $extProperties['Examples']) {
                $extProperties.Add([PSScriptProperty]::new(
                    'Examples', { $this.GetHelpField("Example") }), $true)
            }            
            #endregion .Examples

            #region .Links
            if (-not $extProperties['Links']) {
                $extProperties.Add([PSScriptProperty]::new(
                    'Links', { $this.GetHelpField("Link") }), $true
                )
            }
            #endregion .Links

            #region .Validate
            if (-not $extProperties['Validate']) {
                $extMethods.Add([psscriptmethod]::new('Validate', {
                    param(
                        # input being validated
                        [PSObject]$ValidateInput,
                        # If set, will require all [Validate] attributes to be valid.
                        # If not set, any input will be valid.
                        [switch]$AllValid
                    )

                    foreach ($attr in $this.ScriptBlock.Attributes) {
                        if ($attr -is [Management.Automation.ValidateScriptAttribute]) {
                            try {
                                $_ = $this = $psItem = $ValidateInput
                                $isValidInput = . $attr.ScriptBlock
                                if ($isValidInput -and -not $AllValid) { return $true}
                                if (-not $isValidInput -and $AllValid) {
                                    if ($ErrorActionPreference -eq 'ignore') {
                                        return $false
                                    } elseif ($AllValid) {
                                        throw "'$ValidateInput' is not a valid value."
                                    }
                                }
                            } catch {
                                if ($AllValid) {
                                    if ($ErrorActionPreference -eq 'ignore') {
                                        return $false
                                    } else {
                                        throw
                                    }
                                }
                            }
                        }
                        elseif ($attr -is [Management.Automation.ValidateSetAttribute]) {
                            if ($ValidateInput -notin $attr.ValidValues) {
                                if ($AllValid) {
                                    if ($ErrorActionPreference -eq 'ignore') {
                                        return $false
                                    } else {
                                        throw "'$ValidateInput' is not a valid value.  Valid values are '$(@($attr.ValidValues) -join "','")'"
                                    }
                                }
                            } elseif (-not $AllValid) {
                                return $true
                            }
                        }
                        elseif ($attr -is [Management.Automation.ValidatePatternAttribute]) {
                            $matched = [Regex]::new($attr.RegexPattern, $attr.Options, [Timespan]::FromSeconds(1)).Match("$ValidateInput")
                            if (-not $matched.Success) {
                                if ($allValid) {
                                    if ($ErrorActionPreference -eq 'ignore') {
                                        return $false
                                    } else {
                                        throw "'$ValidateInput' is not a valid value.  Valid values must match the pattern '$($attr.RegexPattern)'"
                                    }
                                }
                            } elseif (-not $AllValid) {
                                return $true
                            }
                        }
                        elseif ($attr -is [Management.Automation.ValidateRangeAttribute]) {
                            if ($null -ne $attr.MinRange -and $validateInput -lt $attr.MinRange) {
                                if ($AllValid) {
                                    if ($ErrorActionPreference -eq 'ignore') {
                                        return $false
                                    } else {
                                        throw "'$ValidateInput' is below the minimum range [ $($attr.MinRange)-$($attr.MaxRange) ]"
                                    }
                                }
                            }
                            elseif ($null -ne $attr.MaxRange -and $validateInput -gt $attr.MaxRange) {
                                if ($AllValid) {
                                    if ($ErrorActionPreference -eq 'ignore') {
                                        return $false
                                    } else {
                                        throw "'$ValidateInput' is above the maximum range [ $($attr.MinRange)-$($attr.MaxRange) ]"
                                    }
                                }
                            }
                            elseif (-not $AllValid) {
                                return $true
                            }
                        }
                    }

                    if ($AllValid) {
                        return $true
                    } else {
                        return $false
                    }
                }), $true)
            }
            #endregion .Validate

            #region .HasValidation
            if (-not $extProperties['HasValidation']) {
                $extProperties.Add([psscriptproperty]::new('HasValidation', {
                    foreach ($attr in $this.ScriptBlock.Attributes) {
                        if ($attr -is [Management.Automation.ValidateScriptAttribute] -or
                            $attr -is [Management.Automation.ValidateSetAttribute] -or 
                            $attr -is [Management.Automation.ValidatePatternAttribute] -or 
                            $attr -is [Management.Automation.ValidateRangeAttribute]) {
                            return $true                        
                        }
                    }

                    return $false
                }), $true)
            }            
            #endregion .HasValidation

            #region .GetDynamicParameters
            if (-not $extMethods['GetDynamicParameters']) {
                $extMethods.Add([PSScriptMethod]::new('GetDynamicParameters', {
                    param(
                    [string]
                    $ParameterSetName,

                    [int]
                    $PositionOffset,

                    [switch]
                    $NoMandatory,

                    [string[]]
                    $commandList
                    )

                    $ExtensionDynamicParameters = [Management.Automation.RuntimeDefinedParameterDictionary]::new()
                    $Extension = $this
                    $ExtensionMetadata = $Extension -as [Management.Automation.CommandMetaData]
                    if (-not $ExtensionMetadata) { return $ExtensionDynamicParameters }

                    :nextDynamicParameter foreach ($in in @(($Extension -as [Management.Automation.CommandMetaData]).Parameters.Keys)) {
                        $attrList = [Collections.Generic.List[Attribute]]::new()
                        $validCommandNames = @()
                        foreach ($attr in $extension.Parameters[$in].attributes) {
                            if ($attr -isnot [Management.Automation.ParameterAttribute]) {
                                # we can passthru any non-parameter attributes
                                $attrList.Add($attr)
                                if ($attr -is [Management.Automation.CmdletAttribute] -and $commandList) {
                                    $validCommandNames += (
                                        ($attr.VerbName -replace '\s') + '-' + ($attr.NounName -replace '\s')
                                    ) -replace '^\-' -replace '\-$'
                                }
                            } else {
                                # but parameter attributes need to copied.
                                $attrCopy = [Management.Automation.ParameterAttribute]::new()
                                # (Side note: without a .Clone, copying is tedious.)
                                foreach ($prop in $attrCopy.GetType().GetProperties('Instance,Public')) {
                                    if (-not $prop.CanWrite) { continue }
                                    if ($null -ne $attr.($prop.Name)) {
                                        $attrCopy.($prop.Name) = $attr.($prop.Name)
                                    }
                                }

                                $attrCopy.ParameterSetName =
                                    if ($ParameterSetName) {
                                        $ParameterSetName
                                    }
                                    else {
                                        $defaultParamSetName =
                                            foreach ($extAttr in $Extension.ScriptBlock.Attributes) {
                                                if ($extAttr.DefaultParameterSetName) {
                                                    $extAttr.DefaultParameterSetName
                                                    break
                                                }
                                            }
                                        if ($attrCopy.ParameterSetName -ne '__AllParameterSets') {
                                            $attrCopy.ParameterSetName
                                        }
                                        elseif ($defaultParamSetName) {
                                            $defaultParamSetName
                                        }
                                        elseif ($this -is [Management.Automation.FunctionInfo]) {
                                            $this.Name
                                        } elseif ($this -is [Management.Automation.ExternalScriptInfo]) {
                                            $this.Source
                                        }
                                    }

                                if ($NoMandatory -and $attrCopy.Mandatory) {
                                    $attrCopy.Mandatory = $false
                                }

                                if ($PositionOffset -and $attr.Position -ge 0) {
                                    $attrCopy.Position += $PositionOffset
                                }
                                $attrList.Add($attrCopy)
                            }
                        }


                        if ($commandList -and $validCommandNames) {
                            :CheckCommandValidity do {
                                foreach ($vc in $validCommandNames) {
                                    if ($commandList -match $vc) { break CheckCommandValidity }
                                }
                                continue nextDynamicParameter
                            } while ($false)
                        }
                        $ExtensionDynamicParameters.Add($in, [Management.Automation.RuntimeDefinedParameter]::new(
                            $Extension.Parameters[$in].Name,
                            $Extension.Parameters[$in].ParameterType,
                            $attrList
                        ))
                    }

                    $ExtensionDynamicParameters

                }), $true)
            }
            #endregion .GetDynamicParameters


            #region .IsParameterValid
            if (-not $extMethods['IsParameterValid']) {
            $extMethods.Add([PSScriptMethod]::new('IsParameterValid', {
                param([Parameter(Mandatory)]$ParameterName, [PSObject]$Value)

                if ($this.Parameters.Count -ge 0 -and 
                    $this.Parameters[$parameterName].Attributes
                ) {
                    foreach ($attr in $this.Parameters[$parameterName].Attributes) {
                        $_ = $value
                        if ($attr -is [Management.Automation.ValidateScriptAttribute]) {
                            $result = try { . $attr.ScriptBlock } catch { $null }
                            if ($result -ne $true) {
                                return $false
                            }
                        }
                        elseif ($attr -is [Management.Automation.ValidatePatternAttribute] -and 
                                (-not [Regex]::new($attr.RegexPattern, $attr.Options, '00:00:05').IsMatch($value))
                            ) {
                                return $false
                            }
                        elseif ($attr -is [Management.Automation.ValidateSetAttribute] -and 
                                $attr.ValidValues -notcontains $value) {
                                    return $false
                                }
                        elseif ($attr -is [Management.Automation.ValidateRangeAttribute] -and (
                            ($value -gt $attr.MaxRange) -or ($value -lt $attr.MinRange)
                        )) {
                            return $false
                        }
                    }
                }
                return $true
            }), $true)
            }
            #endregion .IsParameterValid
            
            #region .CouldPipe
            if (-not $extMethods['CouldPipe']) {
            $extMethods.Add([PSScriptMethod]::new('CouldPipe', {
                param([PSObject]$InputObject)

                :nextParameterSet foreach ($paramSet in $this.ParameterSets) {
                    if ($ParameterSetName -and $paramSet.Name -ne $ParameterSetName) { continue }
                    $params = @{}
                    $mappedParams = [Ordered]@{} # Create a collection of mapped parameters
                    # Walk thru each parameter of this command
                    :nextParameter foreach ($myParam in $paramSet.Parameters) {
                        # If the parameter is ValueFromPipeline
                        if ($myParam.ValueFromPipeline) {
                            $potentialPSTypeNames = @($myParam.Attributes.PSTypeName) -ne ''
                            if ($potentialPSTypeNames)  {                                
                                foreach ($potentialTypeName in $potentialPSTypeNames) {
                                    if ($potentialTypeName -and $InputObject.pstypenames -contains $potentialTypeName) {
                                        $mappedParams[$myParam.Name] = $params[$myParam.Name] = $InputObject
                                        continue nextParameter
                                    }
                                }                                    
                            }
                            # and we have an input object
                            elseif ($null -ne $inputObject -and
                                (
                                    # of the exact type
                                    $myParam.ParameterType -eq $inputObject.GetType() -or
                                    # (or a subclass of that type)
                                    $inputObject.GetType().IsSubClassOf($myParam.ParameterType) -or
                                    # (or an inteface of that type)
                                    ($myParam.ParameterType.IsInterface -and $InputObject.GetType().GetInterface($myParam.ParameterType))
                                )
                            ) {
                                # then map the parameter.
                                $mappedParams[$myParam.Name] = $params[$myParam.Name] = $InputObject
                            }
                        }
                    }
                    # Check for parameter validity.
                    foreach ($mappedParamName in @($mappedParams.Keys)) {
                        if (-not $this.IsParameterValid($mappedParamName, $mappedParams[$mappedParamName])) {
                            $mappedParams.Remove($mappedParamName)
                        }
                    }
                    if ($mappedParams.Count -gt 0) {
                        return $mappedParams
                    }
                }
            }), $true)
            }
            #endregion .CouldPipe

            #region .CouldPipeType
            if (-not $extMethods['CouldPipeType']) {
            $extMethods.Add([PSScriptMethod]::new('CouldPipeType', {
                param([Type]$Type)

                foreach ($paramSet in $this.ParameterSets) {
                    if ($ParameterSetName -and $paramSet.Name -ne $ParameterSetName) { continue }
                    # Walk thru each parameter of this command
                    foreach ($myParam in $paramSet.Parameters) {
                        # If the parameter is ValueFromPipeline
                        if ($myParam.ValueFromPipeline -and (
                                $myParam.ParameterType -eq $Type -or
                                # (or a subclass of that type)
                                $Type.IsSubClassOf($myParam.ParameterType) -or
                                # (or an inteface of that type)
                                ($myParam.ParameterType.IsInterface -and $Type.GetInterface($myParam.ParameterType))
                            )
                        ) {
                            return $true
                        }                        
                    }
                    return $false
                }
            }), $true)
            }
            #endregion .CouldPipeType

            #region .CouldRun
            if (-not $extMethods['CouldRun']) {
            $extMethods.Add([PSScriptMethod]::new('CouldRun', {
                param([Collections.IDictionary]$params, [string]$ParameterSetName)

                :nextParameterSet foreach ($paramSet in $this.ParameterSets) {
                    if ($ParameterSetName -and $paramSet.Name -ne $ParameterSetName) { continue }
                    $mappedParams = [Ordered]@{} # Create a collection of mapped parameters
                    $mandatories  =  # Walk thru each parameter of this command
                        @(foreach ($myParam in $paramSet.Parameters) {
                            if ($params.Contains($myParam.Name)) { # If this was in Params,
                                $mappedParams[$myParam.Name] = $params[$myParam.Name] # then map it.
                            } else {
                                foreach ($paramAlias in $myParam.Aliases) { # Otherwise, check the aliases
                                    if ($params.Contains($paramAlias)) { # and map it if the parameters had the alias.
                                        $mappedParams[$myParam.Name] = $params[$paramAlias]
                                        break
                                    }
                                }
                            }
                            if ($myParam.IsMandatory) { # If the parameter was mandatory,
                                $myParam.Name # keep track of it.
                            }
                        })

                    # Check for parameter validity.
                    foreach ($mappedParamName in @($mappedParams.Keys)) {
                        if (-not $this.IsParameterValid($mappedParamName, $mappedParams[$mappedParamName])) {
                            $mappedParams.Remove($mappedParamName)
                        }
                    }
                    
                    foreach ($mandatoryParam in $mandatories) { # Walk thru each mandatory parameter.
                        if (-not $mappedParams.Contains($mandatoryParam)) { # If it wasn't in the parameters.
                            continue nextParameterSet
                        }
                    }
                    return $mappedParams
                }
                return $false
            }), $true)
            }
            #endregion .CouldRun

            
            # Decorate our return (so that it can be uniquely extended)
            if (-not $ExtensionTypeName) {
                $ExtensionTypeName = 'Extension'
            }
            if ($extCmd.pstypenames -notcontains $ExtensionTypeName) {            
                $extCmd.pstypenames.insert(0,$ExtensionTypeName)
            }

            $extCmd
        }
        }
        function OutputExtension {
            begin {
                $allDynamicParameters = [Management.Automation.RuntimeDefinedParameterDictionary]::new()
            }
            process {
                $extCmd = $_

                # When we're outputting an extension, we start off assuming that it is valid.
                $IsValid = $true
                if ($ValidateInput) { # If we have a particular input we want to validate
                    try {
                        # Check if it is valid
                        if (-not $extCmd.Validate($ValidateInput, $AllValid)) {
                            $IsValid = $false # and then set IsValid if it is not.
                        }
                    } catch {
                        Write-Error $_    # If we encountered an exception, write it out
                        $IsValid = $false # and set is $IsValid to false.
                    }
                }

                
                # If we're requesting dynamic parameters (and the extension is valid)
                if ($IsValid -and 
                    ($DynamicParameter -or $DynamicParameterSetName -or $DynamicParameterPositionOffset -or $NoMandatoryDynamicParameter)) {
                    # Get what the dynamic parameters of the extension would be.
                    $extensionParams = $extCmd.GetDynamicParameters($DynamicParameterSetName, 
                        $DynamicParameterPositionOffset, 
                        $NoMandatoryDynamicParameter, $CommandName)
                    
                    # Then, walk over each extension parameter.
                    foreach ($kv in $extensionParams.GetEnumerator()) {
                        # If the $CommandExtended had a built-in parameter, we cannot override it, so skip it.
                        if ($commandExtended -and ($commandExtended -as [Management.Automation.CommandMetaData]).Parameters.$($kv.Key)) {
                            continue
                        }

                        # If already have this dynamic parameter
                        if ($allDynamicParameters.ContainsKey($kv.Key)) {

                            # check it's type.
                            if ($kv.Value.ParameterType -ne $allDynamicParameters[$kv.Key].ParameterType) {
                                # If the types are different, make it a PSObject (so it could be either).
                                Write-Verbose "Extension '$extCmd' Parameter '$($kv.Key)' Type Conflict, making type PSObject"
                                $allDynamicParameters[$kv.Key].ParameterType = [PSObject]
                            }


                            foreach ($attr in $kv.Value.Attributes) {
                                if ($allDynamicParameters[$kv.Key].Attributes.Contains($attr)) {
                                    continue
                                }
                                $allDynamicParameters[$kv.Key].Attributes.Add($attr)
                            }
                        } else {
                            $allDynamicParameters[$kv.Key] = $kv.Value
                        }
                    }
                }
                elseif ($IsValid -and ($CouldPipe -or $CouldRun)) {
                    if (-not $extCmd) { return }

                    $extensionParams = [Ordered]@{}
                    $pipelineParams = @()
                    if ($CouldPipe) {
                        $couldPipeExt = $extCmd.CouldPipe($CouldPipe)
                        if (-not $couldPipeExt) { return }
                        $pipelineParams += $couldPipeExt.Keys
                        if (-not $CouldRun) {                            
                            $extensionParams += $couldPipeExt
                        } else {
                            foreach ($kv in $couldPipeExt.GetEnumerator()) {
                                $Parameter[$kv.Key] = $kv.Value
                            }
                        }
                    }
                    if ($CouldRun) {
                        $couldRunExt = $extCmd.CouldRun($Parameter, $ParameterSetName)
                        if (-not $couldRunExt) { return }
                        $extensionParams += $couldRunExt
                    }
                
                    [PSCustomObject][Ordered]@{
                        ExtensionCommand = $extCmd
                        CommandName = $CommandName
                        ExtensionInputObject = if ($CouldPipe) { $CouldPipe } else { $null }                        
                        ExtensionParameter   = $extensionParams
                        PipelineParameters   = $pipelineParams
                    }
                }
                elseif ($IsValid -and $SteppablePipeline) {
                    if (-not $extCmd) { return }
                    if ($Parameter) {
                        $couldRunExt = $extCmd.CouldRun($Parameter, $ParameterSetName)
                        if (-not $couldRunExt) {
                            $sb = {&amp; $extCmd }
                            $sb.GetSteppablePipeline() |
                                Add-Member NoteProperty ExtensionCommand $extCmd -Force -PassThru |
                                Add-Member NoteProperty ExtensionParameters $couldRunExt -Force -PassThru |
                                Add-Member NoteProperty ExtensionScriptBlock $sb -Force -PassThru
                        } else {
                            $sb = {&amp; $extCmd @couldRunExt}
                            $sb.GetSteppablePipeline() |
                                Add-Member NoteProperty ExtensionCommand $extCmd -Force -PassThru |
                                Add-Member NoteProperty ExtensionParameters $couldRunExt -Force -PassThru |
                                Add-Member NoteProperty ExtensionScriptBlock $sb -Force -PassThru
                        }
                    } else {
                        $sb = {&amp; $extCmd }
                        $sb.GetSteppablePipeline() |
                            Add-Member NoteProperty ExtensionCommand $extCmd -Force -PassThru |
                            Add-Member NoteProperty ExtensionParameters @{} -Force -PassThru |
                            Add-Member NoteProperty ExtensionScriptBlock $sb -Force -PassThru
                    }
                }
                elseif ($IsValid -and $Run) {
                    if (-not $extCmd) { return }
                    $couldRunExt = $extCmd.CouldRun($Parameter, $ParameterSetName)
                    if (-not $couldRunExt) { return }
                    if ($extCmd.InheritanceLevel -eq 'InheritedReadOnly') { return }
                    if ($Stream) {
                        &amp; $extCmd @couldRunExt
                    } else {
                        [PSCustomObject][Ordered]@{
                            CommandName      = $CommandName
                            ExtensionCommand = $extCmd
                            ExtensionOutput  = &amp; $extCmd @couldRunExt
                            Done             = $extCmd.InheritanceLevel -eq 'NotInherited'
                        }
                    }
                    return
                }
                elseif ($IsValid -and $Help) {
                    $getHelpSplat = @{Full=$true}
                    
                    if ($extCmd -is [Management.Automation.ExternalScriptInfo]) {
                        Get-Help $extCmd.Source @getHelpSplat
                    } elseif ($extCmd -is [Management.Automation.FunctionInfo]) {
                        Get-Help $extCmd @getHelpSplat
                    }
                }
                elseif ($IsValid) {
                    return $extCmd
                }
            }
            end {
                if ($DynamicParameter) {
                    return $allDynamicParameters
                }
            }
        }        
        #endregion Define Inner Functions        

        $extensionFullRegex =
            [Regex]::New($(
                if ($ExtensionModule) {
                    "\.(?&gt;$(@(@($ExtensionModule) + $ExtensionModuleAlias) -join '|'))\." + "(?&gt;$($ExtensionPattern -join '|'))"
                } else {
                    "(?&gt;$($ExtensionPattern -join '|'))"
                }
            ), 'IgnoreCase,IgnorePatternWhitespace', '00:00:01')

        #region Find Extensions
        $loadedModules = @(Get-Module)
        $myInv = $MyInvocation
        $myModuleName = if ($ExtensionModule) { $ExtensionModule } else { $MyInvocation.MyCommand.Module.Name }
        if ($myInv.MyCommand.Module -and $loadedModules -notcontains $myInv.MyCommand.Module) {
            $loadedModules = @($myInv.MyCommand.Module) + $loadedModules
        }
        $getCmd    = $ExecutionContext.SessionState.InvokeCommand.GetCommand

        if ($Force) {
            $script:EZOutExtensions  = $null
            $script:EZOutExtensionsByName    = $null
            $script:AllCommands = @()
        }
        if (-not $script:EZOutExtensions)
        {
            $script:EZOutExtensionsFromFiles     = [Ordered]@{}
            $script:EZOutExtensionsFileTimes     = [Ordered]@{}
            $script:EZOutExtensionsByName        = [Ordered]@{}
            $script:EZOutExtensionsByDisplayName = [Ordered]@{}
            $script:EZOutExtensionsByPattern     = [Ordered]@{}
            $script:EZOutExtensions =
                @(@(
                #region Find EZOutExtensions in Loaded Modules
                foreach ($loadedModule in $loadedModules) { # Walk over all modules.
                    if ( # If the module has PrivateData keyed to this module
                        $loadedModule.PrivateData.$myModuleName
                    ) {
                        # Determine the root of the module with private data.
                        $thisModuleRoot = [IO.Path]::GetDirectoryName($loadedModule.Path)
                        # and get the extension data
                        $extensionData = $loadedModule.PrivateData.$myModuleName
                        if ($extensionData -is [Hashtable]) { # If it was a hashtable
                            foreach ($ed in $extensionData.GetEnumerator()) { # walk each key

                                $extensionCmd =
                                    if ($ed.Value -like '*.ps1') { # If the key was a .ps1 file
                                        $getCmd.Invoke( # treat it as a relative path to the .ps1
                                            [IO.Path]::Combine($thisModuleRoot, $ed.Value),
                                            'ExternalScript'
                                        )
                                    } else { # Otherwise, treat it as the name of an exported command.
                                        $loadedModule.ExportedCommands[$ed.Value]
                                    }
                                if ($extensionCmd) { # If we've found a valid extension command
                                    ConvertToExtension $extensionCmd # return it as an extension.
                                }
                            }
                        }
                    }
                    elseif ($loadedModule.PrivateData.PSData.Tags -contains $myModuleName -or $loadedModule.Name -eq $myModuleName) {
                        $loadedModuleRoot = Split-Path $loadedModule.Path
                        if ($loadedModuleRoot) {
                            foreach ($fileInModule in Get-ChildItem -Path $loadedModuleRoot -Recurse -File -Filter *.ps1) {
                                if ($fileInModule.Name -notmatch $extensionFullRegex) { continue }
                                ConvertToExtension $fileInModule
                            }
                        }
                    }
                }
                #endregion Find EZOutExtensions in Loaded Modules

                #region Find EZOutExtensions in Loaded Commands                
                $ExecutionContext.SessionState.InvokeCommand.GetCommands('*', 'Function,Alias',$true) -match $extensionFullRegex
                #endregion Find EZOutExtensions in Loaded Commands
                ) | Select-Object -Unique | Sort-Object Rank, Name)

            foreach ($extCmd in $script:EZOutExtensions) {
                if (-not $script:EZOutExtensionsByName[$extCmd.Name]) {
                    $script:EZOutExtensionsByName[$extCmd.Name] = $extCmd
                }
                else {
                    $script:EZOutExtensionsByName[$extCmd.Name] = @($script:EZOutExtensionsByName[$extCmd.Name]) + $extCmd
                }
                if ($extCmd.DisplayName) {
                    if (-not $script:EZOutExtensionsByDisplayName[$extCmd.DisplayName]) {
                        $script:EZOutExtensionsByDisplayName[$extCmd.DisplayName] = $extCmd
                    }
                    else {
                        $script:EZOutExtensionsByDisplayName[$extCmd.DisplayName] = @($script:EZOutExtensionsByDisplayName[$extCmd.DisplayName]) + $extCmd
                    }   
                }
                $ExtensionCommandAliases = @($extCmd.Attributes.AliasNames)
                $ExtensionCommandAliasRegexes  = @($ExtensionCommandAliases -match '^/' -match '/$')
                $ExtensionCommandNormalAliases = @($ExtensionCommandAliases -notmatch '^/')
                if ($ExtensionCommandAliasRegexes) {
                    foreach ($extensionAliasRegex in $ExtensionCommandAliasRegexes) {
                        $regex = [Regex]::New($extensionAliasRegex -replace '^/' -replace '/$', 'IgnoreCase,IgnorePatternWhitespace')
                        if (-not $script:EZOutExtensionsByPattern[$regex]) {
                            $script:EZOutExtensionsByPattern[$regex] = $extCmd
                        } else {
                            $script:EZOutExtensionsByPattern[$regex] = @($script:EZOutExtensionsByPattern[$regex]) + $extCmd
                        }
                    }
                }
                if ($ExtensionCommandNormalAliases) {
                    foreach ($extensionAlias in $ExtensionCommandNormalAliases) {
                        if (-not $script:EZOutExtensionsByName[$extensionAlias]) {
                            $script:EZOutExtensionsByName[$extensionAlias] = $extCmd
                        } else {
                            $script:EZOutExtensionsByName[$extensionAlias] = @($script:EZOutExtensionsByName[$extensionAlias]) + $extCmd
                        }
                    }
                }
                
            }
        }
        #endregion Find Extensions
    }

    process {

        if ($ExtensionPath) {
            @(foreach ($_ in Get-ChildItem -Recurse:$($ExtensionPath -notmatch '^\.[\\/]') -Path $ExtensionPath -File) {
                if ($_.Name -notmatch $extensionFullRegex) { continue }
                if ($CommandName -or $ExtensionName) {
                    ConvertToExtension $_ |
                    . WhereExtends $CommandName
                } else {
                    ConvertToExtension $_
                }
            }) |
                #region Install-Piecemeal -WhereObject
                # This section can be updated by using Install-Piecemeal -WhereObject
                #endregion Install-Piecemeal -WhereObject
                Sort-Object Rank, Name |
                OutputExtension
                #region Install-Piecemeal -ForeachObject
                # This section can be updated by using Install-Piecemeal -ForeachObject
                #endregion Install-Piecemeal -ForeachObject
        } elseif ($CommandName -or $ExtensionName) {
            if (-not $CommandName -and -not $like -and -not $Match) {
                foreach ($exn in $ExtensionName) {
                    if ($script:EZOutExtensionsByName[$exn]) {
                        $script:EZOutExtensionsByName[$exn] | OutputExtension
                    }
                    if ($script:EZOutExtensionsByDisplayName[$exn]) {
                        $script:EZOutExtensionsByDisplayName[$exn] | OutputExtension
                    }
                    if ($script:EZOutExtensionsByPattern.Count) {
                        foreach ($patternAndValue in $script:EZOutExtensionsByPattern.GetEnumerator()) {
                            if ($patternAndValue.Key.IsMatch($exn)) {
                                $patternAndValue.Value | OutputExtension
                            }
                        }
                        $script:EZOutExtensionsByDisplayName[$exn]
                    }
                }                
            } else {
                $script:EZOutExtensions |
                    . WhereExtends $CommandName |
                    OutputExtension
            }
            
        } else {
            $script:EZOutExtensions | 
                OutputExtension
        }
    }

                    </Script>
      </ScriptMethod>
      <ScriptMethod>
        <Name>Get-FormatFile</Name>
        <Script>
                        
    &lt;#
    .Synopsis
        Gets format files
    .Description
        Gets loaded format files
    .Example
        Get-FormatFile
    .Example
        Get-FormatFile -OnlyFromModule
    .Example
        Get-FormatFile -OnlyBuildIn
    #&gt;
    param(
    [Switch]$OnlyFromModule,
    [Switch]$OnlyBuiltIn,
    [Switch]$FromSnapins
    )

    process {
        if (-not $OnlyBuiltIn) {
            Get-Module |
                Select-Object -ExpandProperty ExportedFormatFiles |
                Get-Item
        }

        if (-not $OnlyFromModule -and
            -not $FromSnapins) {
            Get-ChildItem $psHome -Filter *.format.ps1xml
        } elseif ($FromSnapins) {
            Get-PSSnapin |
                Where-Object { $_.Formats } |
                ForEach-Object {
                    foreach ($f in $_.Formats) {
                        Get-Item "$($_.ApplicationBase)\$f"
                    }
                }

        }
    }

                    </Script>
      </ScriptMethod>
      <ScriptMethod>
        <Name>Get-PropertySet</Name>
        <Script>
                        
    &lt;#
    .Synopsis
        Gets the property sets
    .Description
        Gets the property sets.  Property sets are predefined views of an object.
    .Example
        Get-PropertySet
    .Example
        Get-PropertySet -TypeName System.Diagnostics.Process
    #&gt;

    [OutputType([PSObject])]
    param(
    # The name of the typename to get
    [string[]]
    $TypeName
    )


    begin {
        $typeFiles = (Get-ChildItem $psHome -Filter *types.ps1xml) +
            @(Get-Module  | Where-Object { $_.ExportedTypeFiles }  | ForEach-Object{ $_.ExportedTypeFiles | Get-Item })
    }
    process {
        $typefiles |
            Select-Xml //PropertySet |
            Where-Object {
                $_.Node.parentnode.parentnode.name -ne 'PSStandardMembers' -and (
                (-not $typeName) -or ($typename -contains $_.Node.parentnode.parentnode.name)
                )
            }  |
            Select-Object @{
                Name='Typename';
                Expression={$_.Node.parentnode.parentnode.name}
            }, @{
                Name='PropertySet';
                Expression = {$_.Node.Name }
            }
    }

                    </Script>
      </ScriptMethod>
      <ScriptMethod>
        <Name>Import-FormatView</Name>
        <Script>
                        
    &lt;#
    .Synopsis
        Imports a Format View
    .Description
        Imports a Format View defined in .format or .view .ps1 files
    .Link
        Write-FormatView
    .EXAMPLE
        # Imports any formatting in the formatting directory
        Import-FormatView -FilePath ./Formatting/ 
    .EXAMPLE
        # Imports any formatting in the types directory
        Import-FormatView -FilePath ./Types/
    #&gt;
    param(
    # The path containing one or more formatting files.
    [Parameter(Mandatory,ValueFromPipelineByPropertyName)]
    [Alias('FullName')]
    [string[]]
    $FilePath,

    # The format file pattern.  
    # This is used to explicitly indicate a file contains PowerShell formatting.
    # By default, it is `'\.(?&gt;format|type|view|control)\.ps1$'`, or:
    # Any `*.format.ps1`, `*.type.ps1`, `*.view.ps1`, or `*.control.ps1`
    [string]    
    $FormatFilePattern = '\.(?&gt;format|type|view|control)\.ps1$'
    )

    begin {
        # Loop over the input files
        # When it's a directory, recursively call yourself
        # When it's a file that doesn't match our pattern, return
        # When it's a .ps1, search attributes from [OutputType()] and [PSTypeName]
        # If the file contained EZOut cmds, run it
        # Otherwise, make it a custom action (convert it to XML)
        # If it was XML, use it directly
        # Pipe to Out-FormatData
        $MySelf = $MyInvocation.MyCommand.ScriptBlock        

        $ezOutCommands=
            @(
            $ezOutModule =  $MyInvocation.MyCommand.ScriptBlock.Module
            foreach ($_ in $ezOutModule.ExportedCommands.Values) {
                $_.Name
            })

        $getViewFileInfo = {
            param(
                [Parameter(Mandatory=$true)][string]$fileName,
                [Parameter(Mandatory=$true)][ScriptBlock]$ScriptBlock
            )

            $typeName = @(foreach ($attr in $ScriptBlock.Attributes) { # check the attributes.
                if ($attr -is [Management.Automation.PSTypeNameAttribute]) { # A typename can come from the PSTypeName attribute
                    $attr.PSTypeName
                }
                if ($attr -is [Management.Automation.OutputTypeAttribute]) { # or the [OutputType] attribute.
                    foreach ($t in $attr.Type) {
                        $t.Name
                    }
                }
            }) | Select-Object -Unique

            # Infer the type name from the file name.
            $inferredTypeName = $fileName -replace $FormatFilePattern

            if (-not $typeName) { # If no typename has been determined by now,
                $typeName = $inferredTypeName # use the inferred type name.
            }

            @{
                TypeName = $typeName
                InferredTypeName = $inferredTypeName
            }
        }
    }

    process {
        $innerFormat = @{}
        $formatterByTypeName = @{}



        foreach ($fp in $FilePath) {
            if ([IO.Directory]::Exists($fp)) {
                $fp |
                    Get-ChildItem |
                    &amp; $MySelf
                continue
            }
            $fi =
                if ([IO.File]::Exists($fp)) {
                    [IO.FileInfo]::new($fp)
                } else {
                    $rp = $ExecutionContext.SessionState.Path.GetResolvedPSPathFromPSPath($fp)
                    if (-not $rp) { continue }
                    [IO.FileInfo]::new("$rp")
                }

            if (-not $fi.Length) {
                continue
            }
            if ('.xml', '.ps1' -notcontains $fi.Extension) { continue }
            # If the file is a [PipeScript](https://github.com/StartAutomating/PipeScript) source generator.
            if ($fi.Name -match '"\.ps1{0,1}\.(?&lt;ext&gt;[^.]+$)"') {
                continue # then skip it
                # (this can simplify development of complex formatting)
            }

            

            if ($fi.Extension -eq '.xml') {
                $innerFormat[$fi.Name] = [xml][IO.File]::ReadAllText($fi.FullName)
            } else {
                $scriptBlock = $ExecutionContext.SessionState.InvokeCommand.GetCommand($fi.FullName, 'ExternalScript').ScriptBlock                 
                
                if ($fi.Name -notmatch $FormatFilePattern) {
                    if (@($ScriptBlock.Attributes.PSTypeName)) {
                        $innerFormat[$fi.FullName] = $scriptBlock
                    }                                        
                } else {
                    $innerFormat[$fi.FullName] = $scriptBlock
                }
                
            }
        }


        foreach ($if in $innerFormat.GetEnumerator()) {
            if ($if.Value -is [ScriptBlock]) {
                $viewFileInfo = (&amp; $getViewFileInfo $if.Key $if.Value)
                $typeName, $inferredTypeName =
                    $viewFileInfo.TypeName, $viewFileInfo.InferredTypeName
                $scriptBlock = $if.Value
                $typeName = @(foreach ($attr in $ScriptBlock.Attributes) { # check the attributes.
                    if ($attr -is [Management.Automation.PSTypeNameAttribute]) { # A typename can come from the PSTypeName attribute
                        $attr.PSTypeName
                    }
                    if ($attr -is [Management.Automation.OutputTypeAttribute]) { # or the [OutputType] attribute.
                        foreach ($t in $attr.Type) {
                            $t.Name
                        }
                    }
                }) | Select-Object -Unique

                


                if (-not $typeName) { # If no typename has been determined by now,
                    # Infer the type name from the file name.                    
                    $formatFileName = $if.Key | Split-Path -Leaf
                    if ($formatFileName -notmatch $FormatFilePattern) {
                        continue
                    }
                    $inferredTypeName = $formatFileName -replace $FormatFilePattern
                    
                    $typeName = $inferredTypeName # then use the inferred type name.
                }
            
                if (-not $formatterByTypeName[$typeName]) {
                    $formatterByTypeName[$typeName] = @()
                }
                $formatterByTypeName[$typeName] += $if
            } elseif ($if.Value -is [xml]) {
                $if.Value
            }
        }

        foreach ($formatterGroup in $formatterByTypeName.GetEnumerator()) {
            foreach ($fileNameAndScriptBlock in $formatterGroup.Value) {
                $fileName, $scriptBlock = $fileNameAndScriptBlock.Key, $fileNameAndScriptBlock.Value                
                if (-not $scriptBlock)  {continue }
                $usesEzOutCommands = $scriptBlock.Ast.FindAll({param($ast)
                    $ast -is [Management.Automation.Language.CommandAst] -and $ezOutCommands -contains $ast.CommandElements[0].Value
                }, $true) | &amp; {
                    begin {
                        $ezOutCmds = [Ordered]@{}
                    }
                    process {
                        $ezOutCmds[$_.CommandElements[0].Value] = $ExecutionContext.SessionState.InvokeCommand.GetCommand($_.CommandElements[0].Value, 'Function,Alias')
                    }
                    end {
                        $ezOutCmds
                    }
                }

                $formatParams = $null
                if ($usesEzOutCommands.Count) { # What commands are used dictate how the formatter will be created.
                    if (@($usesEzOutCommands.Keys)[0] -eq 'Write-FormatViewExpression') {
                        $formatParams = @{
                            Action = [ScriptBlock]::Create($scriptBlock.ToString().Substring($scriptBlock.Ast.ParamBlock.Extent.EndOffset))
                            TypeName = $typeName
                        }
                    } else {
                        $toUnset=
                            @(foreach ($ezOutCmd in $ezOutCommands.GetEnumerator()) {
                                if ($ezOutCmd.Value.Parameters.TypeName) {
                                    $defaultValueName = "$($ezOutCmd.Key):TypeName"
                                    $Global:PSDefaultParameterValues[$defaultValueName] = $typeName
                                    $defaultValueName
                                }
                            })
                        
                        $psTypeNameFile = $null
                        if ($scriptBlock.File) {
                            $psTypeNameFile = 
                                $scriptBlock.File | 
                                    Split-Path | 
                                    Get-ChildItem |
                                    Where-Object Name -Match '^(?:PS)?TypeNames{0,1}\.txt$' | 
                                    Select-Object -First 1
                            if ($psTypeNameFile) {
                                $global:ExecutionContext.SessionState.PSVariable.Set('PSTypeName', @(Get-Content $psTypeNameFile))
                            }
                        }

                        &amp; $scriptBlock
                        foreach ($unset in $toUnset) {
                            $Global:PSDefaultParameterValues.Remove($unset)
                        }
                        if ($psTypeNameFile) {
                            $global:ExecutionContext.SessionState.PSVariable.Remove('PSTypeName')
                        }
                    }
                } else {
                    $formatParams = @{
                        Action = [ScriptBlock]::Create($scriptBlock.ToString().Substring($scriptBlock.Ast.ParamBlock.Extent.EndOffset))
                        TypeName = $typeName
                    }
                }

                if ($formatParams) {
                    Write-FormatView @formatParams
                }
            }
        }

        return
    }

                    </Script>
      </ScriptMethod>
      <ScriptMethod>
        <Name>Import-TypeView</Name>
        <Script>
                        
    &lt;#
    .Synopsis
        Imports Type Views
    .Description
        Imports one or more Type Views from a directory (and an optional list of commands).

        This creates a .types.ps1xml file that can be used to extend the type system of PowerShell.

        Each file in the directory will be treated as a property or method of a type.        
    .Link
        Write-TypeView
    .Example
        Import-TypeView .\Types
    #&gt;
    param(
    # The path containing type information.
    [Parameter(ValueFromPipelineByPropertyName)]
    [Alias('FullName')]
    [string[]]
    $FilePath,
    
    # If set, will generate an identical typeview for the deserialized form of each typename.
    [Parameter(ValueFromPipelineByPropertyName)]
    [switch]$Deserialized,

    # The namespace to use for all imported types.
    # This will be prepended to the type name, and followed by a period.
    [Parameter(ValueFromPipelineByPropertyName)]
    [Alias('Prefix')]
    [string]$Namespace,

    # Any number of commands to import.
    # These commands will converted into ScriptMethods.
    # Each ScriptMethod will it's original command name, within the typename `Commands`.
    # (if -Namespace is provided, the namespace will be prepended to the typename)
    # (only functions are currently supported)
    [Parameter(ValueFromPipelineByPropertyName)]
    [Alias('Commands')]
    [PSObject[]]
    $Command,

    # Any file paths to exclude.
    [Parameter(ValueFromPipelineByPropertyName)]
    [SupportsWildcards()]
    [PSObject[]]
    $ExcludeFilePath,

    # A pattern describing the types of files that will embedded as constant note properties containing the file's text.    
    [Parameter(ValueFromPipelineByPropertyName)]
    [Alias('TextFilePattern')]
    [SupportsWildcards()]
    [PSObject[]]
    $TextFileType = @('.cs','.js','.ts','.htm*','.*proj','.h','.cpp','*.class.ps1')
    )

    process {

        # Commands are converted into ScriptMethods first.
        if ($Command) {
            $writeTypeViewSplat = @{
                TypeName = if ($Namespace) { "$Namespace.Commands" } else { 'Commands' }
                ScriptMethod = [Ordered]@{}                
            }            
            foreach ($cmd in $command) {                
                if ($cmd -is [Management.Automation.FunctionInfo]) {
                    $writeTypeViewSplat.ScriptMethod[$cmd.Name] = $cmd.ScriptBlock
                }
            }
            Write-TypeView @writeTypeViewSplat
        }


        &lt;#
        In order to make something like inheritance work,
        we want to be able to define properties and methods a few places:

        * In the -FilePath directory (these apply to all types)
        * In a directory (these apply to that a type sharing the name of the directory)
        * In any nested subdirectory (these should apply like inherited types)
        #&gt;


        $membersByType = @{}
        $CommonParentPath = $null
        foreach ($fp in $FilePath) {
            $filePathRoot = Get-Item -Path $fp
            if (-not $filePathRoot) { continue}
            if (-not $CommonParentPath) {
                $CommonParentPath = $filePathRoot.Parent.FullName
            } elseif ($CommonParentPath) {
                $CommonParentPath | Split-Path -CommonPrefix $filePathRoot
            }
            $filesBeneathRoot = Get-ChildItem -Recurse -Path $fp -Force

            :nextFile foreach ($fileBeneathRoot in $filesBeneathRoot) {
                if ($fileBeneathRoot -is [IO.DirectoryInfo]) { continue }

                if ($ExcludeFilePath) {
                    foreach ($exclusion in $ExcludeFilePath) {
                        if ($exclusion -is [string] -and 
                            ($file.Name -like $exclusion -or $file.FullName -like $exclusion)) {
                            continue nextFile
                        }
                        if ($exclusion -is [regex] -and                             
                            ($file.Name -match $exclusion -or $file.FullName -match $exclusion)) {
                            continue nextFile
                        }
                    }
                }
                if ($fileBeneathRoot.Directory.FullName -eq $filePathRoot.FullName) {
                    # Files directly beneath the root become methods / properties shared by all typenames
                    if (-not $membersByType['*']) {
                        $membersByType['*'] = @()
                    }
                    $membersByType['*'] += $fileBeneathRoot
                } else {
                    # Files in subdirectories become the methods / properties used by a directory sharing that typename.
                    $subTypeNames = @($fileBeneathRoot.FullName.Substring(
                        $filePathRoot.FullName.Length
                    ).TrimStart(
                        [IO.Path]::DirectorySeparatorChar
                    ).Split([IO.Path]::DirectorySeparatorChar))

                    # Initialize the name of the subtype to zero
                    $subType = ''
                    for (
                        # and walk backwards thru name segements
                        # (skipping the first one, since it's our file name)
                        $subtypeIndex = $subTypeNames.Length - 1;                        
                        $subtypeIndex -ge 0;
                        $subTypeIndex--
                    ) {                                          
                        # If it's the second to last segment, it's our directory name
                        # (the bucket we're using to psuedo-type).
                        if ($subTypeindex -eq ($subTypeNames.Length - 2)) {
                            # Map the subtype
                            $subType = $subTypeNames[$subtypeIndex]
                            if (-not $membersByType[$subType]) {
                                $membersByType[$subType] = @()
                            }
                            # and add this file to it
                            $membersByType[$subType] += $fileBeneathRoot
                        }
                        elseif (
                            # If it's _not_ the subtype, but information is defined on that level
                            $membersByType[$subTypeNames[$subtypeIndex]] -and $subType
                        ) {
                            # we will take everything that is not PSTypeName.txt
                            $membersByType[$subType] += @(
                                @($membersByType[$subTypeNames[$subtypeIndex]]) -notmatch '^(?:PS)?TypeNames{0,1}\.txt$'
                            )

                            # Congratulations!  These very few lines are all it takes to enable inheritance!
                        }
                    }
                }
            }
        }

        if ($membersByType['*']) # If any members applied to all types
        {
            # Apply them to each member first (so that it happens in time),
            foreach ($k in @($membersByType.Keys)) {
                if ($k -ne '*') {
                    $membersByType[$k] += $membersByType['*']
                }
            }
            $membersByType.Remove('*') # then remove it (so we don't do it twice).
        }        
        :nextMember foreach ($mt in $membersByType.GetEnumerator() | Sort-Object Key) {    # Walk thru the members by type
            $WriteTypeViewSplat = @{                         # and create a hashtable to splat.
                TypeName = if ($Namespace) { "$Namespace.$($mt.Key)"} else {$mt.Key}
                Deserialized = $Deserialized
            }
            $OriginalParameterCount = $WriteTypeViewSplat.Count
            # Then, sort the values by name and by if it comes from this directory.
            $sortedValues = $mt.Value | Sort-Object Name, { $_.Directory.Name -ne $mt.Key }

            &lt;#

            At a high level, what we're about to do so is turn a bunch of files into
            a bunch of input for Write-TypeView.

            By default .ps1s will become methods.
            .ps1 files that start with get_ or set_ become properties.
            .ps1 files that start with += become events.

            All other files will become noteproperties.

            Starting a file with . will hide the property.

            It should be noted that hidden ScriptMethods are not "private" Methods, they are just hidden.
            (though neither are C# private Methods, if you use Reflection).

            #&gt;

            $aliasFileNames = 'Alias','Aliases','AliasProperty', '.Alias','.Aliases','.AliasProperty'
            $typeNameFileNames = 'TypeName','TypeNames','PSTypeName', 'PSTypeNames', 
                '.TypeName', '.TypeNames','.PSTypeName', '.PSTypeNames'
            $defaultDisplayFileName = 'DefaultDisplay','.DefaultDisplay'
            $scriptMethods = [Ordered]@{}
            $eventGenerators = [Ordered]@{}
            $eventNames = @()
            $scriptPropertyGet = [Ordered]@{}
            $scriptPropertySet = [Ordered]@{}
            $propertySets = [Ordered]@{}
            $aliasProperty = [Ordered]@{}
            $noteProperty = [Ordered]@{}
            $hideProperty = [Collections.Generic.List[string]]::new()
            foreach ($item in $sortedValues) {

                # If the file is a [PipeScript](https://github.com/StartAutomating/PipeScript) source generator.
                if ($item.Name -match '\.ps1{0,1}\.(?&lt;ext&gt;[^.]+$)') {
                    continue # then skip it
                    # (this can simplify development of ScriptProperties, Methods, and other files).
                }

                # Do not Skip format/view/control files (this allows them to be in the same directory as types, if that is preferred)
                $isFormatFile = $item.Name -match '\.(?&gt;format|view|control)\.ps1$'                
                
                $itemName =
                    $item.Name.Substring(0, $item.Name.Length - $item.Extension.Length)
                
                # If it's a .ps1, it will become a method, property, or event.
                if ($item.Extension -eq '.ps1') {
                    $isScript = $true
                    $scriptBlock = # We'll want the script block.
                        $ExecutionContext.SessionState.InvokeCommand.GetCommand(
                            $item.Fullname, 'ExternalScript'
                        ).ScriptBlock
                } else {
                    $isScript = $false
                }

                # Skip empty scripts, since they will cause the .types.ps1xml to not load.
                if ($isScript -and -not ($scriptBlock -replace '\s')) {
                    continue
                }

                if (-not $isScript -and $itemName -eq $item.Directory.Name) {
                    # If it's a data file that shares the name of the directory
                    # treat it as a "Default" value, and hide the property.
                    $itemName = 'Default'
                    $hideProperty += $itemName
                } elseif ($itemName.StartsWith('.')) {
                    # If the file starts with a ., hide the property.
                    $itemName = $itemName.Substring(1)
                    $hideProperty += $itemName -replace '^(?&gt;get|set)_'
                }



                if ($isScript -and                         # If the file is a script
                    $itemName -match '(?&lt;GetSet&gt;get|set)_' # and it starts with get_ or set_
                    )
                {
                    $propertyName = $itemName.Substring(4) # it's a property.
                    # If it's a get, store it along with the other gets
                    if ($matches.GetSet -eq 'get' -and -not $scriptPropertyGet.Contains($propertyName)) {
                        $scriptPropertyGet[$propertyName] = $scriptBlock

                    }
                    # Otherwise, store it with the sets.
                    elseif (-not $scriptPropertySet.Contains($propertyName))
                    {
                        if ($scriptPropertySet.Contains($propertyName)) {
                            continue
                        }
                        $scriptPropertySet[$propertyName] = $scriptBlock
                    }
                }
                elseif ($isScript -and         # If this is a script and it's an event
                    ($itemName -match '^@' -or # (prefaced with @ -or ending with .event.ps1)
                     $itemName -match '\.event\.ps1$'
                    )
                ) {
                    $eventName = $itemName.Substring(2)

                    $eventGenerators[$eventName] = $scriptBlock # store it for later.
                }
                elseif (
                    $isScript -and  # Otherwise, if it's a script, it's a method.
                    ($item.Name -notlike '*.class.ps1') # (unless it is a class.ps1, in which case skip it or let it become a note property)
                ) 
                {
                    $methodName =$itemName
                    if ($scriptMethods.Contains($methodName)) {
                        continue
                    }
                    $scriptMethods[$methodName] = $scriptBlock
                }
                else
                {
                    # If it's not a method, it's a data file.
                    # Most of these will become properties.
                    $fileText = [IO.File]::ReadAllText($item.FullName)
                    # If the file was a structure all PowerShell engines can read, we'll load it.
                    # Currently, .clixml, .json, .psd1, .txt, and .xml are supported.
                    if ($item.Extension -in '.txt','.psd1', '.xml','.json','.clixml' -and
                        $scriptPropertyGet[$itemName])
                    {
                        # Of course if we've already given this a .ps1, we'd prefer that and will move onto the next.
                        continue
                    }

                    
                    if ($TextFileType) {
                        foreach ($textFilePattern in $TextFileType) {
                            if ($textFilePattern -is [string] -and 
                                ($item.Name -like "*$textFilePattern" -or $item.FullName -like "*$textFilePattern")) {
                                $noteProperty[$item.Name] = $fileText
                            }
                            elseif ($exclusion -is [regex] -and
                                ($item.Name -match $textFilePattern -or $item.FullName -match $textFilePattern)) {
                                $noteProperty[$item.Name] = $fileText                                
                            }
                        }                        
                    }

                    # Let's take a look at the extension to figure out what we do.
                    switch ($item.Extension)
                    {
                        #region .txt Files
                        .txt {

                            if ($defaultDisplayFileName -contains $itemName) # If it's a default display file
                            {
                                # Use each line of the file text as the name of a property to display
                                $WriteTypeViewSplat.DefaultDisplay =
                                    $fileText -split '(?&gt;\r\n|\n)' -ne ''
                            }
                            if ($typeNameFileNames -contains $itemName) {
                                $WriteTypeViewSplat.TypeName =
                                    $fileText -split '(?&gt;\r\n|\n)' -ne ''
                            }
                            elseif ($itemName -like '*.propertySet') { # If it's a property set file (.propertyset.txt)
                                $propertySets[$itemName -replace '\.propertySet$'] = # Create a property set with the file name.
                                    $fileText -split '(?&gt;\r\n|\n)' -ne '' # Each line will be treated as a name of a property.
                            }
                            elseif ($itemName -match '^@') {
                                $eventNames += $itemName.Substring(1)
                            }
                            elseif ($itemName -match '\.event\.txt') {
                                $eventNames += $itemName -replace '\.event$'
                            }
                            elseif (-not $noteProperty.Contains($itemName)) # Otherwise, it's a simple string noteproperty
                            {
                                $noteProperty[$itemName] = $fileText
                            }

                        }

                        .md {
                            if (-not $noteProperty.Contains($itemName)) # Otherwise, it's a simple string noteproperty
                            {
                                $noteProperty[$itemName] = $fileText
                            }
                        }

                        .sql {
                            if (-not $noteProperty.Contains($itemName)) # SQL files become note properties.
                            {
                                $noteProperty[$itemName] = $fileText
                            }
                        }
                        
                        #endregion .txt Files
                        #region .psd1 Files
                        .psd1 {
                            # If it's a .psd1
                            # we load it in a data block
                            # Load it in a data block
                            $dataScriptBlock = [ScriptBlock]::Create(@"
data { $([ScriptBlock]::Create($fileText)) }
"@)
                            if ($aliasFileNames -contains $itemName) # If it's an Alias file
                            {
                                # we load it now
                                $aliasProperty = (&amp; $dataScriptBlock) -as [Collections.IDictionary]
                            } elseif (-not $noteProperty.Contains($itemName)) {
                                # otherwise, we load it in a ScriptProperty
                                $scriptPropertyGet[$itemName] = @"
`$dataObjects = $dataScriptBlock
# Overwrite our own static property with an instance property.
`$this.psobject.properties.add([PSNoteProperty]::new('$itemName', `$dataObjects), `$true)
return `$dataObjects
"@
                            }
                        }
                        #endregion .psd1 Files
                        #region XML files
                        .xml {
                            # Xml content is cached inline in a ScriptProperty and returned casted to [xml]
                            if (-not $noteProperty.Contains($itemName)) {
                            $scriptPropertyGet[$itemName] = [ScriptBlock]::Create(@"
`$fileTextAsXml = [xml]@'
$fileText
'@
# Overwrite our own static property with an instance property.
`$this.psobject.properties.add([PSNoteProperty]::new('$itemName', `$fileTextAsXml), `$true)
return `$fileTextAsXml
"@)
                            }
                        }
                        #endregion XML files
                        #region JSON files
                        .json {
                            # Json files are piped to ConvertFrom-Json
                            if (-not $noteProperty.Contains($itemName)) {
                            $scriptPropertyGet[$itemName] = [ScriptBlock]::Create(@"
`$convertedFromJson = @'
$fileText
'@ | ConvertFrom-Json
# Overwrite our own static property with an instance property.
`$this.psobject.properties.add([PSNoteProperty]::new('$itemName', `$convertedFromJson), `$true)
return `$convertedFromJson
"@)
                            }
                        }
                        #endregion JSON files                        
                        #region CliXML files
                            # Clixml files are embedded into a ScriptProperty and Deserialized.
                        .clixml {
                            if (-not $noteProperty.Contains($itemName)) {
                            $scriptPropertyGet[$itemName] = [ScriptBlock]::Create(@"
`$deserialized = [Management.Automation.PSSerializer]::Deserialize(@'
$fileText
'@)
# Overwrite our own static property with an instance property.
`$this.psobject.properties.add([PSNoteProperty]::new('$itemName', `$deserialized), `$true)
return `$deserialized
"@)
                            }
                        }
                        #endregion CliXML files
                        default {
                            # If we have no clue what kind of file it is, the only good way we can handle it as a byte[]
                            # This is tricky because we are creating a .types.ps1xml file,
                            # which is XML and big enough already.


                            # So we compress it.
                            $fileBytes =                   # Read all the bytes
                                [IO.File]::ReadAllBytes($item.FullName)
                            $ms = [IO.MemoryStream]::new() # Create a new memory stream
                            $gzipStream =                  # Create a gzip stream
                                [IO.Compression.GZipStream]::new($ms, [Io.Compression.CompressionMode]"Compress")
                            $null =                        # Write the file bytes to the stream
                                $gzipStream.Write($fileBytes, 0, $fileBytes.Length)
                            $null = $gzipStream.Close()    # close the stream.  This was the easy part.
                            $itemName = $item.Name
                            if ($itemName.StartsWith('.')) {
                                $itemName = $itemName.Substring(1)
                                $hideProperty += $itemName
                            }
                            if ((-not $scriptPropertyGet.Contains($itemName)) -and (-not $noteProperty[$item.Name])) {
                                # The hard part is dynamically creating the unpacker.
                                # The get script will need to do the above steps in reverse, and read the bytes back
                                $scriptPropertyGet[$itemName] = [ScriptBlock]::Create(@"

`$stream =
    [IO.Compression.GZipStream]::new(
        [IO.MemoryStream]::new(
            [Convert]::FromBase64String(@'
$(
# We do this by embedding the byte[] inside a Heredoc in Base64
[Convert]::ToBase64String($ms.ToArray(), "InsertLineBreaks")
)
'@)
        ),
        [IO.Compression.CompressionMode]'Decompress'
    );
"@ + @'

$BufferSize = 1kb
$buffer = [Byte[]]::new($BufferSize)
$bytes =
    do {
        $bytesRead= $stream.Read($buffer, 0, $BufferSize )
        $buffer[0..($bytesRead - 1)]
        if ($bytesRead -lt $BufferSize ) {
            break
        }
    } while ($bytesRead -eq $BufferSize )
$bytes -as [byte[]]
$stream.Close()
$stream.Dispose()
'@)

                            }
                        }
                    }
                }
            }



            if ($scriptMethods.Count) {
                $WriteTypeViewSplat.ScriptMethod = $scriptMethods
            }
            if ($aliasProperty.Count) {
                $WriteTypeViewSplat.AliasProperty = $aliasProperty
            }
            if ($propertySets.Count) {
                $WriteTypeViewSplat.PropertySet = $propertySets
            }
            if ($scriptPropertyGet.Count -or $scriptPropertySet.Count) {
                $scriptProperties = [Ordered]@{}
                foreach ($k in $scriptPropertyGet.Keys) {
                    $scriptProperties[$k] = $scriptPropertyGet[$k]
                }
                foreach ($k in $scriptPropertySet.Keys) {
                    if (-not $scriptProperties[$k]) {
                        $scriptProperties[$k] = {return $null}, $scriptPropertySet[$k]
                    } else {
                        $scriptProperties[$k] = $scriptProperties[$k], $scriptPropertySet[$k]
                    }
                }
                $WriteTypeViewSplat.ScriptProperty = $scriptProperties
            }

            if ($noteProperty.Count) {
                $WriteTypeViewSplat.NoteProperty = $noteProperty
            }

            if ($eventGenerators.Count) {
                $WriteTypeViewSplat.EventGenerator = $eventGenerators
            }

            if ($eventNames) {
                $WriteTypeViewSplat.EventName = $eventNames
            }

            # If we have added any parameters to splat, we will write the type view.
            if ($WriteTypeViewSplat.Count -gt $OriginalParameterCount) {
                $WriteTypeViewSplat.HideProperty = $hideProperty                
                Write-TypeView @WriteTypeViewSplat
            }
        }
    }

                    </Script>
      </ScriptMethod>
      <ScriptMethod>
        <Name>Out-Alternate</Name>
        <Script>
                        
    &lt;#
    .SYNOPSIS
        Outputs alternate views
    .DESCRIPTION
        Outputs alternate views of an object or typename.
        
        While it is possible to display multiple views of an object in PowerShell, it's not as straightforward to see what those views are.
        
        Out-Alternate solves this problem, and is embeddable within a format file.
    .EXAMPLE
        Out-Alternate -TypeName "System.Diagnostics.Process"
    #&gt;
    [Management.Automation.Cmdlet("Format", "Object")]
    param(
    # An input object.  If this is provided, it will infer the typenames
    [Parameter(ValueFromPipeline)]
    [PSObject]
    $InputObject,
    
    # The typename of the alternate.
    # If this is not provided, it can be inferred from the `-InputObject`.
    [Alias('TypeName')]
    [string[]]
    $PSTypeName,

    # The name of the current view.
    # If this is provided, it will not be displayed as an alternate.
    [string]
    $CurrentView,

    # A prefix to each view.
    [string]
    $Prefix = "",

    # A suffix to each view.
    [string]
    $Suffix,

    # If set, will not padd the space between the name of the format control and the -View parameter
    [switch]
    $NoPadding,

    # The name of one or more modules.
    # If provided, will provide the -PS1XMLPath of each module's .ExportedFormatFiles
    [string[]]
    $ModuleName,

    # The path to one or more .ps1xml files.
    # If these are provided (or inferred thru -ModuleName), will look for alternates in PS1XML.
    [string[]]
    $PS1XMLPath
    )
    
    begin {
        if (-not $script:AlternateViewCache) {
            $script:AlternateViewCache = @{}
        } 
    }

    process {
        # If no typename was provided
        if (-not $PSTypeName) {
            # and the input object has one
            if ($InputObject.pstypenames) {
                # use the input's PSTypeNames
                $PSTypeName = $InputObject.pstypenames
            }
        }

        # If we have no PSTypename, return.
        if (-not $PSTypeName) { return }

        if (-not $script:AlternateViewCache["$PSTypeName"]) {
            if ($ModuleName -and -not $PS1XMLPath) {                
                $PS1XMLPath = (Get-Module $ModuleName).ExportedFormatFiles
            }
                
            $script:AlternateViewCache["$PSTypeName"] =  # Get the views and force them into an array
                @(if ($PS1XMLPath) {
                    foreach ($ps1xml in $PS1XMLPath) {
                        if (-not $ps1xml) { continue }
                        Select-Xml -Path $ps1xml -XPath //TypeName |
                            &amp; { process {
                                if ($_.Node.InnerText -and 
                                    $_.Node.InnerText.Trim() -notin $PSTypeName
                                ) {
                                    return
                                }
                                $_.Node.ParentNode.ParentNode
                            } }                    
                    }
                } else {
                    foreach ($typeName in $PSTypeName) {
                        foreach ($view in (Get-FormatData -TypeName $TypeName).FormatViewDefinition) {
                            $view
                        }
                    }
                })
        }

        $views = $script:AlternateViewCache["$PSTypeName"]

        # Now we walk over each view
        @(foreach ($view in $views) {
            # If we provided a -CurrentView, and this is it, skip.
            if ($CurrentView -and $view.Name -eq $CurrentView) { continue }
            # Determine the format type
            $formatType = if ($view.Control) {
                # by getting the control and removing "Control" from the typename (if using Get-FormatData).
                $view.Control.GetType().Name -replace 'Control$'
            } else {
                foreach ($potentialType in 'Table', 'List', 'Wide', 'Custom') {
                    if ($view."${potentialType}Control") {
                        $potentialType;break
                    }
                }
            }

            if (-not $formatType) { continue }
            

            # By default, we pad space (for aesthetic reasons).
            if (-not $NoPadding) { # If `-NoPadding` was passed, we won't pad space.
                # Otherwise, always pad to 6.
                # (the length of 'Custom', the longest of the potential format types)
                $formatType = $formatType.PadRight(6, ' ')
            }
            # Now output the name of the format command and it's view.
            "Format-$formatType -View '$($view.Name -replace "'", "''")'"
        }) -join [Environment]::NewLine
    }    

                    </Script>
      </ScriptMethod>
      <ScriptMethod>
        <Name>Out-FormatData</Name>
        <Script>
                        

    &lt;#
    .Synopsis
        Takes a series of format views and format actions and outputs a format data XML
    .Description
        A Detailed Description of what the command does
    .Example
        # Create a quick view for any XML element.
        # Piping it into Out-FormatData will make one or more format views into a full format XML file
        # Piping the output of that into Add-FormatData will create a temporary module to hold the formatting data
        # There's also a Remove-FormatData and
        Write-FormatView -TypeName "System.Xml.XmlNode" -Wrap -Property "Xml" -VirtualProperty @{
            "Xml" = {
                $strWrite = New-Object IO.StringWriter
                ([xml]$_.Outerxml).Save($strWrite)
                "$strWrite"
            }
        } |
            Out-FormatData
    #&gt;
    [OutputType([string])]
    param(
    # The Format XML Document.  The XML document can be supplied directly,
    # but it's easier to use Write-FormatView to create it
    [Parameter(Mandatory=$true,
        ValueFromPipeline=$true)]
    [ValidateScript({
        if ((-not $_.View) -and (-not $_.Control) -and (-not $_.SelectionSet)) {
            throw "The root of a format XML most contain either a View or a Control element"
        }
        return $true
    })]
    [Xml]
    $FormatXml,
    # The name of the module the format.ps1xml applies to.
    # This is required if you are using colors.
    # This is required if you use any dynamic parts (named script blocks stored a /Parts) directory.
    [string]
    $ModuleName = 'EZOut',
    
    
    # The output path.
    # This can be a string or a dictionary.
    # If it is a dictionary, the keys must a be a `[string]` or `[regex]` defining a pattern, and the value will be the path.
    [ValidateScript({
    $validTypeList = [System.String],[System.Collections.IDictionary]
    
    $thisType = $_.GetType()
    $IsTypeOk =
        $(@( foreach ($validType in $validTypeList) {
            if ($_ -as $validType) {
                $true;break
            }
        }))
    
    if (-not $isTypeOk) {
        throw "Unexpected type '$(@($thisType)[0])'.  Must be 'string','System.Collections.IDictionary'."
    }
    return $true
    })]
        
    [PSObject]
    $OutputPath
    )
    begin {
       
$Aspect = {
                                                param($ast)
                                
                                                if ($ast -is [Management.Automation.Language.CommandAst]) {
                                                    $ast
                                                }
                                            }
 $views = ""
        $controls = ""
        $selectionSets = ""
        
        function findUsedParts {
        
                            param(
                                [Parameter(Mandatory,ValueFromPipelineByPropertyName)]
                                [Alias('InnerText','ScriptBlock','ScriptContents')]
                                [string]$InScript,
                                
                                [PSModuleInfo[]]
                                $FromModule = @(Get-Module),
                                
                                # If set, will look for a part globally if it does not find in any of the modules.
                                [switch]
                                $AllowGlobal
                                )
                                
                                begin {
                                    if (-not $script:LookedUpCommands) {
                                        $script:LookedUpCommands = @{}
                                    }
                                    if (-not $script:CommandModuleLookup) {
                                        $script:CommandModuleLookup = @{}
                                    }
                                    $GetVariableValue = {
                                        param($name)
                                        $ExecutionContext.SessionState.PSVariable.Get($name).Value
                                    }            
                                }
                                
                                    process {
                                        $in = $_
                                
                                        $inScriptBlock = try { [scriptblock]::Create($InScript) } catch { $null }
                                
                                        if ($inScriptBlock.Ast) {
                                            $cmdRefs = @($inScriptBlock.Ast.FindAll($Aspect, $true))
                                
                                            foreach ($cmd in $cmdRefs) {
                                                $variableName = 
                                                    if ($cmd.CommandElements[0].VariablePath) {
                                                        "$($cmd.CommandElements[0].VariablePath)"
                                                    } else { '' }
                                                $commandName =
                                                    if ($cmd.CommandElements[0].Value) {
                                                        $cmd.CommandElements[0].Value
                                                    }
                                
                                                if (-not ($variableName -or $commandName)) { continue }
                                                $foundCommand = 
                                                    foreach ($module in $FromModule) {
                                                        $foundIt = 
                                                            if ($variableName) {
                                                                &amp; $module $GetVariableValue $variableName
                                                            } elseif ($commandName) {
                                                                $script:CommandModuleLookup["$commandName"] = $module
                                                                $module.ExportedCommands[$commandName]
                                                            }
                                                        if ($foundIt -and $variableName) {
                                                            $script:CommandModuleLookup[$variableName] = $module
                                                            if ($foundIt -is [ScriptBlock]) {
                                                                $PSBoundParameters.InScript = "$foundIt"
                                                                if ("$foundIt") {
                                                                    &amp; $MyInvocation.MyCommand.ScriptBlock @PSBoundParameters
                                                                }
                                                            }
                                                            $foundIt; break
                                                        } elseif ($foundIt -and $commandName) {
                                                            $script:CommandModuleLookup[$commandName] = $module
                                                            $foundIt
                                                        }
                                                    }
                                
                                                if (-not $foundCommand -and $AllowGlobal) {
                                                    $foundCommand = &amp; $getVariableValue $variableName
                                                }
                                                if ($variableName) {
                                                    $script:LookedUpCommands["$variableName"] = $foundCommand
                                                    $PartName = "$variableName"
                                                } elseif ($commandName) {
                                                    $script:LookedUpCommands["&amp; $commandName"]  = 
                                                        if ($foundCommand.ScriptBlock) {
                                                            $foundCommand.ScriptBlock
                                                        } 
                                                        elseif ($foundCommand.ResolvedCommand.ScriptBlock) {
                                                            $foundCommand.ResolvedCommand.ScriptBlock
                                                        }
                                                        else {
                                                            $isOk = $false
                                                        }
                                                        $PartName = "&amp; $commandName"
                                
                                                    $isOk =
                                                        foreach ($attr in $foundCommand.ScriptBlock.Attributes) {
                                                            if ($attr -is [Management.Automation.CmdletAttribute]){
                                                                $extensionCommandName = (
                                                                    ($attr.VerbName -replace '\s') + '-' + ($attr.NounName -replace '\s')
                                                                ) -replace '^\-' -replace '\-$'
                                                                if ('Format-Object' -match $extensionCommandName) {
                                                                    $true
                                                                    break
                                                                }
                                                            }
                                                        }
                                
                                                    if (-not $isOk) { continue }
                                                }
                                
                                                
                                                if ($script:LookedUpCommands[$partName] -and $script:LookedUpCommands[$partName] -isnot [ScriptBlock]) {
                                                    continue 
                                                }
                                                [PSCustomObject][Ordered]@{
                                                    Name = $PartName
                                                    CommandName = $commandName
                                                    VariableName = $variableName
                                                    ScriptBlock = $script:LookedUpCommands[$PartName]
                                                    Module = $script:CommandModuleLookup[$PartName]                    
                                                    FindInput = $in
                                                }                
                                            }
                                        }                                        
                                }
                        
                
        }
        filter ReplaceParts {
        
                            if ($DebugPreference -ne 'silentlyContinue') {
                                $in = $_
                                if ($in.InnerText) { return $in.InnerText}
                                else { return $in }
                            }
                            $inScriptBlock = try { [scriptblock]::Create($_) } catch { $null }
                            $inScriptString = "$inScriptBlock"
                            $cmdRefs = @($inScriptBlock.Ast.FindAll($Aspect, $true))
                            $replacements = @()
                            foreach ($cmd in $cmdRefs) {
                                $partName = 
                                    if ($cmd.CommandElements[0].VariablePath) {
                                        "$($cmd.CommandElements[0].VariablePath)"
                                    } elseif ($cmd.CommandElements[0].Value) {
                                        "&amp; $($cmd.CommandElements[0].Value)"
                                    } else  { ''}
                                
                                foreach ($part in $foundParts) {
                                    if ("$($part.Name)" -eq $partName) {
                                        $replacements += @{
                                            Ast = $cmd.CommandElements[0]
                                            ReplacementText = if ($newPartNames.$partName) { $newPartNames.$partName} else {$partName}
                                        }
                                        break
                                    }
                                }
                            }
                            $stringBuilder = [Text.StringBuilder]::new()
                            $stringIndex   =0            
                            $null = for ($rc = 0; $rc -lt $replacements.Length; $rc++) {
                                if ($replacements[$rc].Ast.Extent.StartOffset -gt $stringIndex) {
                                    $stringBuilder.Append($inScriptString.Substring($stringIndex, $replacements[$rc].Ast.Extent.StartOffset - $stringIndex))
                                }
                                $stringBuilder.Append($replacements[$rc].ReplacementText)
                                $stringIndex = $replacements[$rc].Ast.extent.Endoffset
                            }
                            $null = $stringBuilder.Append($inScriptString.Substring($stringIndex))
                            "$stringBuilder"
                        
                
        }
        $importFormatParts = {
            do {
                $lm = Get-Module -Name $moduleName -ErrorAction Ignore
                if (-not $lm) { continue } 
                if ($lm.FormatPartsLoaded) { break }
                $wholeScript = @(foreach ($formatFilePath in $lm.exportedFormatFiles) {         
                    foreach ($partNodeName in Select-Xml -LiteralPath $formatFilePath -XPath "/Configuration/Controls/Control/Name[starts-with(., '$')]") {
                        $ParentNode = $partNodeName.Node.ParentNode
                        "$($ParentNode.Name)={
            $($ParentNode.CustomControl.CustomEntries.CustomEntry.CustomItem.ExpressionBinding.ScriptBlock)}"
                    }
                }) -join [Environment]::NewLine
                New-Module -Name "${ModuleName}.format.ps1xml" -ScriptBlock ([ScriptBlock]::Create(($wholeScript + ';Export-ModuleMember -Variable *'))) |
                    Import-Module -Global
                $onRemove = [ScriptBlock]::Create("Remove-Module '${ModuleName}.format.ps1xml'")
                
                if (-not $lm.OnRemove) {
                    $lm.OnRemove = $onRemove
                } else {
                    $lm.OnRemove = [ScriptBlock]::Create($onRemove.ToString() + ''  + [Environment]::NewLine + $lm.OnRemove)
                }
                $lm | Add-Member NoteProperty FormatPartsLoaded $true -Force
            
            } while ($false)
            
        }
    }
    process {
        if ($FormatXml.View) {
            $views += "&lt;View&gt;$($FormatXml.View.InnerXml)&lt;/View&gt;"
        } elseif ($FormatXml.Control) {
            $controls += "&lt;Control&gt;$($FormatXml.Control.InnerXml)&lt;/Control&gt;"
        } elseif ($FormatXml.SelectionSet) {
            $selectionSets += "&lt;SelectionSet&gt;$($FormatXml.SelectionSet.InnerXml)&lt;/SelectionSet&gt;"
        }
    }
    end {
        $newPartNames = @{}
        $configuration = "
        &lt;!-- Generated with EZOut $($MyInvocation.MyCommand.Module.Version): Install-Module EZOut or https://github.com/StartAutomating/EZOut --&gt;
        &lt;Configuration&gt;
        "
        if ($selectionSets) {
            $configuration += "&lt;SelectionSets&gt;$selectionSets&lt;/SelectionSets&gt;"
        }
        if ($Controls) {
            $Configuration+="&lt;Controls&gt;$Controls&lt;/Controls&gt;"
        }
        if ($Views) {
            $Configuration+="&lt;ViewDefinitions&gt;$Views&lt;/ViewDefinitions&gt;"
        }
        $configuration += "&lt;/Configuration&gt;"
        $configurationXml = [xml]$configuration
        if (-not $configurationXml) { return }
        
        # Now we need to go looking parts used within &lt;ScriptBlock&gt; elements.
        # Before we do, we need to determine where to look.
        if (-not $PSBoundParameters.ContainsKey('ModuleName')) # If no -ModuleName was provided,
        {
            $callStackPeek = @(Get-PSCallStack) # use call stack peeking
            $callingFile = $callStackPeek[1].InvocationInfo.MyCommand.ScriptBlock.File # to find the calling file
            $fromEzOutFile =  $callingFile -like '*.ez*.ps1' # and see if it's an EZOut file
            if ($fromEzOutFile)
            {   # If it is,
                $moduleName = ($callingFile | Split-Path -Leaf) -replace '\.ezformat\.ps1','' # guess
                Write-Warning "No -ModuleName provided, guessing $ModuleName"  # then warn that we guessed.
            }
        }
        $modulesThatMayHaveParts =
            @(
            $theModule = $null
            $theModuleExtensions = @()
            $myModule = $MyInvocation.MyCommand.ScriptBlock.Module
            $myModuleExtensions = @()
            $loadedModules = Get-Module
            foreach ($lm in $loadedModules) {
                if ($moduleName -and $lm.Name -eq $moduleName) {
                    $theModule = $lm
                    foreach ($_ in $theModule.RequiredModules) {
                        if ($moduleName -and (
                            ($_.Name -eq $moduleName) -or
                            ($_.PrivateData.PSData.Tags -contains $ModuleName))
                        ) {
                            $theModuleExtensions += $lm
                        }
                    }
                }
                foreach ($_ in $lm.RequiredModules) {
                    if ($myModule -and (
                        ($_.Name -eq $myModule.Name) -or
                        ($_.PrivateData.PSData.Tags -contains $myModule.Name))
                    ) {
                        $myModuleExtensions += $lm
                    }
                }
            }
            $theModule
            $theModuleExtensions
            $myModule
            $myModuleExtensions
            ) | Select-Object -Unique
        $foundParts = # See if the XML refers to any parts
            @($configurationXml.SelectNodes("//ScriptBlock") | Where-Object InnerText) |
                    findUsedParts -FromModule $modulesThatMayHaveParts
        # If any parts are found, we'll need to embed them and bootstrap the loader
        if ($foundParts -and $DebugPreference -eq 'silentlyContinue') { 
            if (-not $moduleName) # To do this, we need a -ModuleName, so we if we still don't have one.
            {
                Write-Error "A -ModuleName must be provided to use advanced features" # error
                return # and return.
            }
            $alreadyEmbedded = @()
            $embedControls =
                @(foreach ($part in $foundParts) { # and embed each part in a comment
                    if ($alreadyEmbedded -contains $part.Name) { continue }
                    $partName =
                        if ($part.Name -match '\w+' -or $moduleName -match '\w+') {
                            "`${${ModuleName}_$($part.Name -replace '^[&amp;\.] ')}"
                        } else {
                            "`$${ModuleName}_$($part.Name -replace '^[&amp;\.] ')"
                        }
                    if ($partName -and $part.ScriptBlock -and $alreadyEmbedded -notcontains $partName) {
                        $newPartNames["$($part.Name)"]= if ($part.CommandName) { "&amp; $partName" } else { "$partName"}
                        if (-not ($part.ScriptBlock -as [ScriptBLock[]])) {
                            continue
                        }                        
                        Write-FormatView -AsControl -Name "$partName" -Action $part.ScriptBlock -TypeName 'n/a'
                    }
                    $alreadyEmbedded += $part.Name
                })
            $controlsElement =
                if (-not $configurationXml.Configuration.Controls) {
                    $configurationXml.CreateNode([Xml.XmlNodeType]::Element,'Controls','')
                } else {
                    $configurationXml.Configuration.Controls
                }
            foreach ($ec in $embedControls) {
                $ecx = [xml]$ec
                $controlsElement.InnerXml += $ecx.Control.OuterXml
            }
            if (-not $configurationXml.Configuration.Controls) { # If we didn't already have controls
                $null = $configurationXml.Configuration.AppendChild($controlsElement) # add the &lt;Controls&gt; element
            } else {
                $foundParts = # Otherwise, we need to find our parts again, because the XML has changed
                    @($configurationXml.SelectNodes("//ScriptBlock")) | # and we want to rewrite the part references.
                        findUsedParts -FromModule $modulesThatMayHaveParts
            }
            $lastEntryNode = $null
            $replacedItIn = @()
            foreach ($fp in $foundParts) {
                if (-not $fp.ScriptBlock) {
                    continue
                }
                $newScriptText = @(
                    if ($lastEntryNode -ne $fp.FindInput.ParentNode.ParentNode.ParentNode) {
                        # If the grandparent node is a distinct &lt;Entry&gt;,
                        # we need to bootload the parts (because this is a potential entry point)
                        "`$moduleName = '$($ModuleName.Replace("'","''"))'"
                        "$ImportFormatParts"
                    }
                    if ($replacedItIn -notcontains $fp.FindInput) {
                        $fp.FindInput.InnerText | ReplaceParts
                        $replacedItIn += $fp.FindInput
                    } else {
                        $fp.FindInput.InnerText
                    }
                ) -join [Environment]::NewLine
                $lastEntryNode = $fp.FindInput.ParentNode.ParentNode.ParentNode
                $fp.FindInput.InnerText = $newScriptText
            }
        }
        if (-not $configurationXml) { return }
        
        if ($OutputPath) {
            $alreadyExportedTypeNames = @{}
            $allTypeNames = @()

            if ($outputPath -is [string]) {
                $createdOutputFile = New-Item -ItemType File -Path $OutputPath -Force
                if (-not $createdOutputFile) { return }
                $configurationXml.Save($createdOutputFile.FullName)
                Get-Item -LiteralPath $createdOutputFile.FullName                
            }
            else {                
                $fileOutputs = [Ordered]@{}  
                $viewsXml = "&lt;Views&gt;$views&lt;/Views&gt;" -as [xml]
                if (-not $viewsXml) { return }
                :nextView foreach ($view in $viewsXml.Views.View) {                    
                    $viewTypeNames = @($view.ViewSelectedBy.TypeName)
                    if (($OutputPath -isnot [Collections.IDictionary])) { continue } 
                    foreach ($outPath in $OutputPath.GetEnumerator()) {
                        if ($alreadyExportedTypeNames[$viewTypeNames]) { 
                                    continue nextView                        
                                } 
                        if (($outPath.Key -isnot [regex] -and $outPath.Key -isnot [string])) { continue } 
                        if (($outPath.Key -is [string] -and -not ($viewTypeNames -like $outPath.Key))) { continue } 
                        if (($outPath.Key -is [Regex] -and -not ($viewTypeNames -match $outPath.Key))) { continue } 
                                                
                        if (-not $fileOutputs[$outPath.Value]) {
                            $fileOutputs[$outPath.Value] = @()
                        }
                        $fileOutputs[$outPath.Value] += $view
                        $alreadyExportedTypeNames[$viewTypeNames] = $kv.Value
                        continue nextView
                    }                                   
                }
                foreach ($fileOut in $fileOutputs.GetEnumerator()) {
                    $controlsInThisFile = [Ordered]@{}
                    
                    $fileViews = "
                    &lt;ViewDefinitions&gt;$(foreach ($view in $fileOut.Value) {
                        $customControlReferences = $view.SelectNodes(".//CustomControlName")
                        if (-not $customControlReferences) { continue }
                        $controlsXml = "&lt;Controls&gt;$Controls&lt;/Controls&gt;" -as [xml]
                        foreach ($controlRef in $customControlReferences) {
                            $refName = $controlRef.InnerText.Trim()
                            if (-not $controlsInThisFile[$refName]) {
                                $controlsInThisFile[$refName] = $controlsXml.SelectSingleNode("./Controls/Control[Name='$refname']").OuterXml
                            }                                 
                        }
                        $view.OuterXml                        
                    })&lt;/ViewDefinitions&gt;
                    "
                    $fileControls = if ($controlsInThisFile.Count) {
                        "&lt;Controls&gt;$(@($controlsInThisFile.Values))&lt;/Controls&gt;"
                    } else { $null }
                    $fileXml = "
                    &lt;!-- Generated with EZOut $($MyInvocation.MyCommand.Module.Version): Install-Module EZOut or https://github.com/StartAutomating/EZOut --&gt;
                    &lt;Configuration&gt;${FileViews}${FileControls}&lt;/Configuration&gt;
                    " -as [xml]
                    if (-not $fileXml) { continue }
                    $filePath = $fileOut.Key
                    $createdOutputFile = New-Item -ItemType File -Path $filePath -Force
                    if (-not $createdOutputFile) { continue }
                    $fileXml.Save($createdOutputFile.FullName)
                    Get-Item -LiteralPath $createdOutputFile.FullName
                }                
            }            
        } else {
            $strWrite = [IO.StringWriter]::new()
            $configurationXml.Save($strWrite)
            return "$strWrite"
        }
        
    }


                    </Script>
      </ScriptMethod>
      <ScriptMethod>
        <Name>Out-Gum</Name>
        <Script>
                        


&lt;#
.Synopsis
    Outputs using Gum
.Description
    
    Allows you to format objects using [CharmBraclet's Gum](https://github.com/charmbracelet/gum).
    
.Example
    'live', 'die' | Out-Gum choose
.Example
    'What is best in life?' | Out-Gum -Command input
.Link
    https://github.com/charmbraclet/gum
#&gt;
[CmdletBinding(PositionalBinding=$false)]
[Management.Automation.Cmdlet("Format", "Object")]
[Alias("gum")]
param(
&lt;#
The Command in Gum.
|CommandName|Description|
|-|-|
|choose|Choose an option from a list of choices|
|confirm|Ask a user to confirm an action|
|file|Pick a file from a folder|
|filter|Filter items from a list|
|format|Format a string using a template|
|input|Prompt for some input|
|join|Join text vertically or horizontally|
|pager|Scroll through a file|
|spin|Display spinner while running a command|
|style|Apply coloring, borders, spacing to text|
|table|Render a table of data|
|write|Prompt for long-form text|
|log|Log messages to output|
#&gt;
[Parameter(Mandatory,Position=0)]
[ValidateSet('choose','confirm','file','filter','format','input','join','pager','spin','style','table','write','log')]
[String]
$Command,
# The input object.
[Parameter(ValueFromPipeline)]
[Management.Automation.PSObject]
$InputObject,
# Any additional arguments to gum (and any remaining arguments)
[Parameter(ValueFromRemainingArguments)]
[Alias('GumArguments')]
[String[]]
$GumArgument
)

begin {

   
$isPipedFrom=$($myInvocation.PipelinePosition -lt $myInvocation.PipelineLength)
 $accumulateInput = [Collections.Queue]::new()

}
process {

    if ($inputObject) {
        $accumulateInput.Enqueue($inputObject)
    }

}
end {

    $gumCmd = $ExecutionContext.SessionState.InvokeCommand.GetCommand('gum', 'Application')
    if (-not $gumCmd) {
        Write-Error "Gum not installed"
        return
    }

    #region Fix Gum Arguments
    $allGumArgs = @(
        foreach ($gumArg in $gumArgument) {
            # Fix single dashing / slashing parameter convention.
            if ($gumArg -match '^[-/]\w') {
                $gumArg -replace '^[-/]', '--'
            } else {
                $gumArg
            }
        }
    )
    #endregion Fix Gum Arguments

    Write-Verbose "Calling gum with $allGumArgs"

    if ($accumulateInput.Count) {
        $MustConvert = $false
        $filteredInput = @(
        foreach ($inputObject in $accumulateInput) {
            if (-not $inputObject.GetType) { continue } 
            if ($inputObject -is [string] -or $inputObject.IsPrimitive) {
                $inputObject
            } else {
                $MustConvert = $true
                $inputObject
            }
        })
        if ($MustConvert) {
            $filteredInput = $filteredInput | ConvertTo-Csv
        }

        if ($isPipedFrom) {
            $gumOutput = $filteredInput | &amp; $gumCmd $Command @allGumArgs
            $gumOutput
        } else {
            $filteredInput | &amp; $gumCmd $Command @allGumArgs
        }

    } else {
        if ($isPipedFrom) {
            $gumOutput = $filteredInput | &amp; $gumCmd $Command @allGumArgs
            $gumOutput
        } else {
            &amp; $gumCmd $Command @allGumArgs
        }
    }

}



                    </Script>
      </ScriptMethod>
      <ScriptMethod>
        <Name>Out-Mermaid</Name>
        <Script>
                        
    &lt;#
    .SYNOPSIS
        Outputs Mermaid
    .DESCRIPTION
        Outputs Mermaid Diagrams.
    .NOTES    
        This will also attempt to transform non-string objects into the appropriate input for a diagram.
    .EXAMPLE
        Out-Mermaid "flowchart TD
            Start --&gt; Stop"
    .EXAMPLE
        [Ordered]@{
            title="Pets Adopted By Owners"
            Dogs=386
            Cats=85
            Rats=15
        } | 
            Out-Mermaid pie
    .EXAMPLE
        [Ordered]@{
            title = "A Gantt Diagram"
            dateFormat = "YYYY-MM-DD"
            "section Section" = [Ordered]@{
                "A task" = "a1,2014-01-01,30d"
                "Another Task" = "after a1, 20d"
            }
            "section Another" = [Ordered]@{
                "Task in Another" = "2014-01-12",'12d'
                "Another Task" =  "24d"
            }        
        } | Out-Mermaid -Diagram "gantt"
    .EXAMPLE
        '
        Alice-&gt;&gt;John: Hello John, how are you?
        John--&gt;&gt;Alice: Great!
        Alice-)John: See you later!    
        '| 
        Out-Mermaid -Diagram sequenceDiagram     
    #&gt;
    [Management.Automation.Cmdlet("Format","Object")]
    [CmdletBinding(PositionalBinding=$false)]
    param(
    # The mermaid diagram.
    [Parameter(Position=0)]
    [string]
    $Diagram,

    # Any input to the diagram.
    # This will be appended to the diagram definition.
    # This tries to serialize properties and arrays into their appropriate format in Mermaid.
    # Strings will be included inine.  Keys/values will be joined with either spaces or colons (depending on depth and type).
    [Parameter(ValueFromPipeline)]
    $InputObject,

    # If set, will include the Mermaid diagram within a `pre` element with the css class `mermaid`.
    [switch]
    $AsHtml,

    # If set, will not include either a markdown code fence or an HTML control around the Mermaid.
    [Alias('Sparse','Bare')]
    [switch]
    $Raw,

    # The String Value Separator (the value that separates a key from it's value).
    # If set, this will override any presumptions Out-Mermaid might make.
    [string]
    $StringValueSeparator = ''
    )

    begin {
        $accumulateInput = [Collections.Queue]::new()
        $recursiveDepth = 0
        foreach ($callstack in Get-PSCallStack) {
            if ($callstack.InvocationInfo.MyCommand.ScriptBlock -eq $MyInvocation.MyCommand.ScriptBlock) {
                $recursiveDepth++
            }
        }
        $mySelf =  $MyInvocation.MyCommand.ScriptBlock
    }

    process {
        if ($InputObject) {
            if ($InputObject -is [Collections.IDictionary]) {
                $accumulateInput.Enqueue([PSCustomObject]$InputObject)
            } else {
                $accumulateInput.Enqueue($InputObject)
            }
            
        }
    }

    end {
        if ($accumulateInput.Count) {
            if ($Diagram) {
                $Diagram += " "
            }
            $Diagram += 
                @(foreach ($acc in $accumulateInput.ToArray()) {
                    if ($acc -is [string]) {
                        # Include strings as is
                        $acc
                        ' ' # with a space after
                    } else {
                        # Otherwise, we're producing a series of nested elements
                        $propList = @($acc.psobject.properties)
                        for ($propIndex = 0 ;$propIndex -lt $propList.Length; $propIndex++) {                        
                            $prop = $propList[$propIndex]

                            if ($prop.Value -is [array]) {
                                if ($prop.Value -as [double[]]) {
                                    $prop.Name + ' ' + '[' + ($prop.Value -join ',') + ']'
                                } elseif ($(
                                    :AllInnerValuesAreStrings do {
                                        foreach ($innerValue in $prop.Value) {
                                            if ($innerValue -isnot [string]) {
                                                $false; break AllInnerValuesAreStrings
                                            }
                                        }
                                        $true
                                    } while ($false)
                                )) {
                                    $prop.Name + ':' + ($prop.Value -join ', ')
                                } else {

                                }
                            }
                            
                            elseif ( # If the values are not strings                                
                                $prop.Value -isnot [string] -and 
                                $prop.Value.GetType -and 
                                $prop.Value.GetType().IsPrimitive # (and are primitive types)
                            ) {
                                # Then we want to quote the name and put the value after a colon.
                                "`"$($prop.Name)`"" + ':' + $prop.Value
                            } elseif ($prop.Value -is [string]) {
                                # Otherwise, we want to include the name and the value.
                                if ($StringValueSeparator) {
                                    $prop.Name + $StringValueSeparator + $prop.Value
                                } elseif ($recursiveDepth -eq 1) {
                                    $prop.Name + ' ' + $prop.Value
                                } else {
                                    $prop.Name + ':' + $prop.Value
                                }                                
                            } else {
                                $prop.Name
                                [Environment]::NewLine
                                (' ' * 4 * ($recursiveDepth + 1))
                                &amp; $mySelf -Raw -InputObject $prop.Value
                            }
                            [Environment]::NewLine
                            if ($propIndex + 1 -lt $propList.Length) {
                                (' ' * 4 * $recursiveDepth)
                            }
                        }
                    }
                }) -join ''
        }
        
        if ($Diagram) {
            if ($raw) {
                $Diagram
            }
            elseif ($AsHtml) {
                @('&lt;pre class="mermaid"&gt;'
                $Diagram
                '&lt;/pre&gt;') -join [Environment]::NewLine
            } 
            else {
                @('```mermaid'
                $Diagram
                '```') -join [Environment]::NewLine
            }
        }
    }

                    </Script>
      </ScriptMethod>
      <ScriptMethod>
        <Name>Out-TypeData</Name>
        <Script>
                        

    &lt;#
    .Synopsis
        Takes a series of type views and format actions and outputs a type data XML
    .Description
        Takes a series of type views and format actions and outputs a type data XML
    .Example
        # Create a quick view for any XML element.
        # Piping it into Out-FormatData will make one or more format views into a full format XML file
        # Piping the output of that into Add-FormatData will create a temporary module to hold the formatting data
        # There's also a Remove-FormatData and
        Write-FormatView -TypeName "System.Xml.XmlNode" -Wrap -Property "Xml" -VirtualProperty @{
            "Xml" = {
                $strWrite = New-Object IO.StringWriter
                ([xml]$_.Outerxml).Save($strWrite)
                "$strWrite"
            }
        } |
            Out-FormatData

    #&gt;
    param(
    # The Format XML Document.  The XML document can be supplied directly,
    # but it's easier to use Write-FormatView to create it
    [Parameter(Mandatory=$true,
        ValueFromPipeline=$true)]
    [ValidateScript({
        if ((-not $_.Type)) {
            throw "The root of a types XML most be a type element"
        }
        return $true
    })]
    [Xml]
    $TypeXml,

    # The output path.
    # This can be a string or a dictionary.
    # If it is a dictionary, the keys must a be a `[string]` or `[regex]` defining a pattern, and the value will be the path.
    [ValidateScript({
    $validTypeList = [System.String],[System.Collections.IDictionary]
    
    $thisType = $_.GetType()
    $IsTypeOk =
        $(@( foreach ($validType in $validTypeList) {
            if ($_ -as $validType) {
                $true;break
            }
        }))
    
    if (-not $isTypeOk) {
        throw "Unexpected type '$(@($thisType)[0])'.  Must be 'string','System.Collections.IDictionary'."
    }
    return $true
    })]
        
    [PSObject]
    $OutputPath
    )

    begin {
        $type = ""
    }
    process {
        if ($TypeXml.Type) {
            $type+= "&lt;Type&gt;$($TypeXml.Type.InnerXml)&lt;/Type&gt;"
        }
    }

    end {
        $xml = [xml]"
        &lt;!-- Generated with EZOut $($MyInvocation.MyCommand.Module.Version): Install-Module EZOut or https://github.com/StartAutomating/EZOut --&gt;
        &lt;Types&gt;
        $type
        &lt;/Types&gt;
        "

        if ($OutputPath) {            
            if ($outputPath -is [string]) {
                $createdOutputFile = New-Item -ItemType File -Path $OutputPath -Force
                if (-not $createdOutputFile) { return }
                $xml.Save($createdOutputFile.FullName)
                Get-Item -LiteralPath $createdOutputFile.FullName                
            }
            else {
                $fileOutputs = [Ordered]@{}  
                $alreadyExportedTypeNames = @{}
                $allTypeNames = @()
                
                :nextType foreach ($typeXml in $xml.Types.Type) {                    
                    $viewTypeNames = @($typeXml.Name)
                    $allTypeNames += $viewTypeNames                    
                    if (($OutputPath -isnot [Collections.IDictionary])) { continue } 
                    foreach ($outPath in $OutputPath.GetEnumerator()) {
                        if ($alreadyExportedTypeNames[$viewTypeNames]) { 
                                    continue nextType                        
                                } 
                        if (($outPath.Key -isnot [regex] -and $outPath.Key -isnot [string])) { continue } 
                        if (($outPath.Key -is [string] -and -not ($viewTypeNames -like $outPath.Key))) { continue } 
                        if (($outPath.Key -is [Regex] -and -not ($viewTypeNames -match $outPath.Key))) { continue } 
                                                
                        if (-not $fileOutputs[$outPath.Value]) {
                            $fileOutputs[$outPath.Value] = @()
                        }
                        $fileOutputs[$outPath.Value] += $typeXml.OuterXml
                        $alreadyExportedTypeNames[$viewTypeNames] = $kv.Value
                        continue nextType
                    }                                   
                }
                foreach ($fileOut in $fileOutputs.GetEnumerator()) {                    
                    $fileXml = "
                    &lt;!-- Generated with EZOut $($MyInvocation.MyCommand.Module.Version): Install-Module EZOut or https://github.com/StartAutomating/EZOut --&gt;
                    &lt;Types&gt;$($fileOut.Value -join [Environment]::NewLine)&lt;/Types&gt;
                    "                                    
                    if (-not $fileXml) { continue }
                    $filePath = $fileOut.Key
                    $createdOutputFile = New-Item -ItemType File -Path $filePath -Force
                    if (-not $createdOutputFile) { continue }
                    ($fileXml -as [xml]).Save($createdOutputFile.FullName)
                    Get-Item -LiteralPath $createdOutputFile.FullName
                }                
            }            
        } else {
            $strWrite = [IO.StringWriter]::new()
            $xml.Save($strWrite)
            return "$strWrite"
        }        
    }


                    </Script>
      </ScriptMethod>
      <ScriptMethod>
        <Name>Pop-FormatData</Name>
        <Script>
                        
    &lt;#
    .Synopsis
        Removes formatting from the current session.
    .Description
        Pop-FormatData command removes dynamically loaded formatting data from the current session.
    .Link
        Push-FormatData    
    #&gt;
    [CmdletBinding(DefaultParameterSetName="ByModuleName")]
    param(
    # The name of the format module.  If there is only one type name,then
    # this is the name of the module.
    [Parameter(ParameterSetName='ByModuleName',
        Mandatory=$true,
        ValueFromPipeline=$true)]
    [String]
    $ModuleName
    )


    process {
        # Use @() to walk the hashtable first,
        # so we can modify it within the foreach
        foreach ($kv in @($FormatModules.GetEnumerator())) {
            if ($psCmdlet.ParameterSetName -eq "ByModuleName") {
                if ($kv.Key -eq $ModuleName) {
                    Remove-Module $kv.Key
                    $null = $FormatModules.Remove($kv.Key)
                }
            }
        }
    }

                    </Script>
      </ScriptMethod>
      <ScriptMethod>
        <Name>Pop-TypeData</Name>
        <Script>
                        
    &lt;#
    .Synopsis
        Removes Type information from the current session.
    .Description
        Pop-TypeData command removes dynamically created type data from the current session.
    .Link
        Push-TypeData
    #&gt;
    [CmdletBinding(DefaultParameterSetName="ByModuleName")]
    param(
    # The name of the Type module.  If there is only one type name,then
    # this is the name of the module.
    [Parameter(ParameterSetName='ByModuleName',
        Mandatory=$true,
        ValueFromPipeline=$true)]
    [String]
    $ModuleName
    )


    process {
        # Use @() to walk the hashtable first,
        # so we can modify it within the foreach
        foreach ($kv in @($TypeModules.GetEnumerator())) {
            if ($psCmdlet.ParameterSetName -eq "ByModuleName") {
                if ($kv.Key -eq $ModuleName) {
                    Remove-Module $kv.Key
                    $null = $TypeModules.Remove($kv.Key)
                }
            }
        }
    }

                    </Script>
      </ScriptMethod>
      <ScriptMethod>
        <Name>Push-FormatData</Name>
        <Script>
                        
    &lt;#
    .Synopsis
        Pushes formatting to the current session.
    .Description
        Push-FormatData pushes formatting data into the current session.

        The formatting data is defined in .Format.ps1xml files (such as those in the $pshome directory).
        Add-FormatData will take one or more XML documents containing format data and will create a
        temporary module to use the formatting file.
    .Link
        Clear-FormatData
    .Link
        Pop-FormatData
    .Link
        Out-FormatData
    .Example
        # Let's start off by looking at how something like XML is rendered in PowerShell
        [xml]"&lt;a an='anattribute'&gt;&lt;b d='attribute'&gt;&lt;c/&gt;&lt;/b&gt;&lt;/a&gt;"

        # It's not very intuitive.
        # I cannot really only see the element I am looking at, instead of a chunk of data

        # Create a quick view for any XML element.
        # Piping it into Out-FormatData will make one or more format views into a full format XML file
        # Piping the output of that into Add-FormatData will create a temporary module to hold the formatting data
        # There's also a Remove-FormatData and
        Write-FormatView -TypeName "System.Xml.XmlNode" -Wrap -Property "Xml" -VirtualProperty @{
            "Xml" = {
                $strWrite = New-Object IO.StringWriter
                ([xml]$_.Outerxml).Save($strWrite)
                "$strWrite"
            }
        } |
            Out-FormatData |
            Push-FormatData

        # Now let's take a look at how the xml renders
        [xml]"&lt;a an='anattribute'&gt;&lt;b d='attribute'&gt;&lt;c /&gt;&lt;/b&gt;&lt;/a&gt;"

        # In case we want to go back to the original formatter, we can use Clear-FormatData to return
        # to the old formatting data
        Clear-FormatData

        # And we're back to the original formatting
        [xml]"&lt;a an='anattribute'&gt;&lt;b d='attribute'&gt;&lt;c/&gt;&lt;/b&gt;&lt;/a&gt;"
    #&gt;
    [OutputType([Nullable], [PSModuleInfo])]
    [Alias('Add-FormatData')]
    param(
    # The Format XML Document.  The XML document can be supplied directly,
    # but it's easier to use Write-FormatView to create it
    [Parameter(Mandatory=$true,
        ValueFromPipeline=$true)]
    [ValidateScript({
        if ((-not $_.Configuration)) {
            throw "The root of a format XML most be a Configuration element"
        }
        return $true
    })]
    [Xml]
    $FormatXml,

    # The name of the format module.  If the name is not provided, the name of the module will be the first
    # type name encountered.  If no typename is encountered, the name of the module will be FormatModuleN, where
    # N is the number of modules loaded so far
    [string]
    $Name,

    # If set, the module that contains the format files will be outputted to the pipeline
    [Switch]
    $PassThru
    )

    begin {
        # Create a list of all of the format files that will be loaded in this batch.
        $formatFiles = @()
    }

    process {
        #region Create a temporary file to hold each of the formatters
        $tempDir = $env:Temp, '/tmp' -ne '' | Select-Object -First 1
        $tempFile = Join-Path $tempDir ([IO.Path]::GetRandomFileName())
        $formatFileName = "${tempFile}.Format.ps1xml"
        $FormatXml.Save($FormatFileName)
        $formatFiles += (Get-Item $formatFileName).Name
        #endregion Create a temporary file to hold each of the formatters
    }

    end {
        #region Generate Module for the Type
        if (-not $Name) {
            $typeName = $FormatXml.SelectSingleNode("//TypeName")
            if ($typeName) {
                $Name = $typeName.'#text'
            } else {
                $Name = "FormatModule$($FormatModules.Count + 1)"
            }

        }
        $Name = $Name.Replace("#","").Replace("\","").Replace("/","").Replace(":","")

        $tempFile = Join-Path $tempDir $Name
        $tempFile = "${tempFile}_${pid}.psd1" # this path was colliding with other processes because its type name was fixed
        # old: 'C:\Users\User\AppData\Local\Temp\System.Text.RegularExpressions.Match.psd1'
        # new: 'C:\Users\User\AppData\Local\Temp\System.Text.RegularExpressions.Match_1234.psd1'

        Get-Module $Name -ErrorAction SilentlyContinue |
            Remove-Module
        $ModuleManifestParameters = @{
            FormatsToProcess = $FormatFiles
            NestedModules = @()
            Author = $env:UserName
            CompanyName = ""
            Copyright = Get-Date
            ModuleToProcess =  ""
            RequiredModules = @()
            Description = ""
            RequiredAssemblies = @()
            TypesToProcess = @()
            FileList = $FormatFiles
            Path = $tempFile
        }
        New-ModuleManifest @ModuleManifestParameters
        if ($script:FormatModules.Count) {
            $script:FormatModules.Values | Where-Object { $_ } |Import-Module -Force
        }
        $module = Import-Module $tempFile -Force -PassThru
        $script:formatModules[$Name] = $module
        if ($passThru) { $module }
        &lt;#
        I didn't delete the $TempFile here because other cmdlets might assume it's not removed,
           when they reference '$script:formatModules'
        #&gt;
        #endregion Generate Module for the Type
    }

                    </Script>
      </ScriptMethod>
      <ScriptMethod>
        <Name>Push-TypeData</Name>
        <Script>
                        
    &lt;#
    .Synopsis
        Pushes type data into the current session.
    .Description
        Push-TypeData pushes type data into the current session.

        This creates a temporary module to store information declared in a types file and imports it.
    .Link
        Clear-TypeData
    .Link
        Pop-TypeData
    .Link
        Out-TypeData
    #&gt;
    [OutputType([Nullable],[PSModuleInfo])]
    [Alias('Add-TypeData')]
    param(
    # The Format XML Document.  The XML document can be supplied directly,
    # but it's easier to use Write-FormatView to create it
    [Parameter(Mandatory=$true,
        ValueFromPipeline=$true)]
    [ValidateScript({
        if ((-not $_.Types)) {
            throw "The root of a types XML most be a types element"
        }
        return $true
    })]
    [Xml]
    $TypeXml,

    &lt;#
    The name of the format module.
    If the name is not provided, the name of the module will be the first type name encountered.
    If no typename is encountered, the name of the module will be FormatModuleN
    (where N is the number of modules loaded so far).
    #&gt;
    [string]
    $Name,

    # If set, the module that contains the format files will be outputted to the pipeline
    [Switch]
    $PassThru
    )

    begin {
        # Create a list of all of the format files that will be loaded in this batch.
        $typeFiles = @()
    }

    process {
        #region Create a temporary file to hold each of the type files
        $tempDir = $env:Temp, '/tmp' -ne '' | Select-Object -First 1
        $tempFile = Join-Path $tempDir ([IO.Path]::GetRandomFileName())
        $typeFileName = "${tempFile}.Type.ps1xml"
        $TypeXml.Save($typeFileName)
        $typeFiles += (Get-Item $typeFileName).Name
        #endregion Create a temporary file to hold each of the type files
    }

    end {
        #region Generate a Module to hold the item
        if (-not $name) {
            $typeName = $TypeXml.SelectSingleNode("//Name")
            if ($typeName) {
                $name = $typeName.'#text'
            } else {
                $name = "TypeModule$($TypeModules.Count + 1)"
            }
        }

        $Name = $Name.Replace("#","").Replace("\","").Replace("/","")

        $tempFile = Join-Path $tempDir $name
        $tempFile = "${tempFile}.psd1"
        Get-Module $name -ErrorAction SilentlyContinue |
            Remove-Module
        $ModuleManifestParameters = @{
            FormatsToProcess = @()
            NestedModules = @()
            Author = $env:UserName
            CompanyName = ""
            Copyright = Get-Date
            ModuleToProcess =  ""
            RequiredModules = @()
            Description = ""
            RequiredAssemblies = @()
            TypesToProcess = $TypeFiles
            FileList = $TypeFiles
            Path = $tempFile
        }
        New-ModuleManifest @ModuleManifestParameters
        if ($script:TypeModules.Count) {
            $script:TypeModules.Values | Import-Module -Force
        }
        $module = Import-Module $tempFile -Force -PassThru
        $script:TypeModules[$name] = $module
        if ($passThru) { $module }

        #endregion Generate a Module to hold the item
    }

                    </Script>
      </ScriptMethod>
      <ScriptMethod>
        <Name>Write-EZFormatFile</Name>
        <Script>
                        
    &lt;#
    .Synopsis
        Creates a new EZFormat file.
    .Description
        Creates a new EZFormat file.  EZFormat files use EZOut to create format and types files for a module.
    #&gt;
    param(
    # Any -FormatView commands.
    [Parameter(ValueFromPipelineByPropertyName)]
    [ScriptBlock[]]
    $Format,

    # Any -TypeView commands.
    [Parameter(ValueFromPipelineByPropertyName)]
    [ScriptBlock[]]
    $Type,

    # The name of the module.  By default, this will be inferred from the name of the file.
    [Parameter(ValueFromPipelineByPropertyName)]
    [Alias('Name')]    
    [string]
    $ModuleName = @'
$($myFile | Split-Path -Leaf) -replace '\.ezformat\.ps1', '' -replace '\.ezout\.ps1', ''
'@,


    # The source path.  By default, the script's root.
    [Parameter(ValueFromPipelineByPropertyName)]
    [string]
    $SourcePath = @'
$myFile | Split-Path
'@,

    # The destination path.  By default, the script's root.
    [Parameter(ValueFromPipelineByPropertyName)]
    [Alias('DestPath')]
    [string]
    $DestinationPath = @'
$myRoot
'@,

    # The output path for the .ezout file.
    # If no output path is provided, the code will be outputted directly.
    [Parameter(ValueFromPipelineByPropertyName)]
    [string]
    $OutputPath
    )

    begin {
        $ezFormatTemplate = @'
#requires -Module EZOut
#  Install-Module EZOut or https://github.com/StartAutomating/EZOut
$myFile = $MyInvocation.MyCommand.ScriptBlock.File
$myModuleName = $_ModuleName
$myRoot = $_MyRoot
Push-Location $myRoot
$formatting = @(
    # Add your own Write-FormatView here,
    # or put them in a Formatting or Views directory
    foreach ($potentialDirectory in 'Formatting','Views','Types') {
        Join-Path $myRoot $potentialDirectory |
            Get-ChildItem -ea ignore |
            Import-FormatView -FilePath {$_.Fullname}
    }
)

$destinationRoot = $_MyDestination

if ($formatting) {
    $myFormatFilePath = Join-Path $destinationRoot "$myModuleName.format.ps1xml"
    # You can also output to multiple paths by passing a hashtable to -OutputPath.
    $formatting | Out-FormatData -Module $MyModuleName -OutputPath $myFormatFilePath
}

$types = @(
    # Add your own Write-TypeView statements here
    # or declare them in the 'Types' directory
    Join-Path $myRoot Types |
        Get-Item -ea ignore |
        Import-TypeView
)

if ($types) {
    $myTypesFilePath = Join-Path $destinationRoot "$myModuleName.types.ps1xml"
    # You can also output to multiple paths by passing a hashtable to -OutputPath.
    $types | Out-TypeData -OutputPath $myTypesFilePath
}

$MyModuleIsLoaded = Get-Module $MyModuleName
if ($MyModuleIsLoaded) {
    $myCommandTypesFilePath = Join-Path $destinationRoot "$myModuleName.commands.types.ps1xml"
    Import-TypeView -Commands @($MyModuleIsLoaded.ExportedFunctions.Values) -Namespace $myModuleName | Out-TypeData -OutputPath $myCommandTypesFilePath
}
Pop-Location
'@
    }


    process {
        $ezFormatTemplate = $ezFormatTemplate.Replace('$_ModuleName', $(
            if ($ModuleName.StartsWith('$')) {
                $ModuleName
            } else {
                "'$($ModuleName.Replace("'","''"))'"
            }
        ))
        $ezFormatTemplate = $ezFormatTemplate.Replace('$_MyRoot', $(
            if ($SourcePath.StartsWith('$')) {
                $SourcePath
            } else {
                "'$($SourcePath.Replace("'","''"))'"
            }
        ))
        $ezFormatTemplate = $ezFormatTemplate.Replace('$_MyDestination', $(
            if ($DestinationPath.StartsWith('$')) {
                $DestinationPath
            } else {
                "'$($DestinationPath.Replace("'","''"))'"
            }
        ))
        if ($Type) {
            $ezFormatTemplate = $ezFormatTemplate.Replace('# Write-TypeView', $Type -join [Environment]::NewLine)
        }
        if ($Format) {
            $ezFormatTemplate = $ezFormatTemplate.Replace('# Write-FormatView', $Format -join [Environment]::NewLine)
        }

        if (-not $OutputPath) {
            return $ezFormatTemplate
        }

        $ezFormatTemplate | Set-Content -Path $OutputPath
        if ($?) { Get-Item -LiteralPath $OutputPath }
        
    }

                    </Script>
      </ScriptMethod>
      <ScriptMethod>
        <Name>Write-FormatControl</Name>
        <Script>
                        
    &lt;#
    .Synopsis
        Writes the Format XML for a Control
    .Description
        Writes the .format.ps1xml for a custom control.  Custom Controls can be reused throughout the formatting file.
    .Example

    .Link
        Write-FormatCustomView
    #&gt;
    param(
    # The name of the control
    [Parameter(Mandatory=$true,ValueFromPipelineByPropertyName=$true)]
    [String]$Name,

    &lt;#

    The script block used to fill in the contents of a custom control.


    The script block can either be an arbitrary script, which will be run,
    or it can contain a series of Write-FormatViewExpression commands.

    If the ScriptBlock contains Write-FormatViewExpression,
    code in between Write-FormatViewExpression will not be included in the formatter
    #&gt;
    [Parameter(Mandatory=$true,ValueFromPipelineByPropertyName=$true)]
    [Alias('ScriptBlock', 'DefaultAction')]
    [ScriptBlock]$Action
    )

    process {
        $Splat = $PSBoundParameters |
            &amp; ${?@} -Command Write-FormatCustomView
        $Splat.AsControl = $true
        $splat | &amp; ${.@}
    }

                    </Script>
      </ScriptMethod>
      <ScriptMethod>
        <Name>Write-FormatCustomView</Name>
        <Script>
                        
    &lt;#
    .Synopsis
        Writes the format XML for a custom view.
    .Description
        Writes the .format.ps1xml fragement for a custom control view, or a custom control.
    .Link
        Write-FormatViewExpression
    .Link
        Write-FormatView
    .Link
        Write-FormatControl
    .Example
        Write-FormatCustomView -Action {  "This is a message from Process $pid" }
    #&gt;
    [Alias('Write-CustomAction')]
    param(
    # The script block used to fill in the contents of a custom control.
    # The script block can either be an arbitrary script, which will be run, or it can include a
    # number of speicalized commands that will translate into parts of the formatter.
    [Parameter(Mandatory=$true,ValueFromPipelineByPropertyName=$true)]
    [Alias('ScriptBlock')]
    [ScriptBlock[]]$Action,

    # If set, will put the expression within a &lt;Frame&gt; element.
    [Parameter(ValueFromPipelineByPropertyName)]
    [switch]
    $Frame,

    # If provided, will indent by a number of characters.  This implies -Frame.
    [Parameter(ValueFromPipelineByPropertyName)]
    [Alias('Indent')]
    [ValidateRange(0,1mb)]
    [int]
    $LeftIndent,

    # If provided, will indent the right by a number of characters.  This implies -Frame.
    [Parameter(ValueFromPipelineByPropertyName)]
    [ValidateRange(0,1mb)]
    [int]
    $RightIndent,

    # Specifies how many characters the first line of data is shifted to the left.  This implies -Frame.
    [Parameter(ValueFromPipelineByPropertyName)]
    [ValidateRange(0,1mb)]
    [int]
    $FirstLineHanging,

    # Specifies how many characters the first line of data is shifted to the right.  This implies -Frame.
    [Parameter(ValueFromPipelineByPropertyName)]
    [ValidateRange(0,1mb)]
    [int]
    $FirstLineIndent,

    # If set, the content will be created as a control.  Controls can be reused by other formatters.
    [Switch]$AsControl,

    # The name of the action
    [String]$Name,

    # The VisibilityCondition parameter is used to add a condition that will determine
    # if the content will be rendered.
    [ScriptBlock[]]$VisibilityCondition = {},

    # If provided, the table view will only be used if the the typename is this value.
    # This is distinct from the overall typename, and can be used to have different table views for different inherited objects.
    [Parameter(ValueFromPipelineByPropertyName=$true)]
    [string]
    $ViewTypeName,

    # If provided, the table view will only be used if the the typename is in a SelectionSet.
    # This is distinct from the overall typename, and can be used to have different table views for different inherited objects.
    [Parameter(ValueFromPipelineByPropertyName=$true)]
    [string]
    $ViewSelectionSet,

    # If provided, will selectively display items.
    # Must be used with -ViewSelectionSet and -ViewTypeName.
    # At least one view must have no conditions.
    [Parameter(ValueFromPipelineByPropertyName=$true)]
    [ScriptBlock]
    $ViewCondition)


    begin {
        $entries = @()
    }
    process {
        $entrySelectedBy =
            if ($ViewTypeName -or $ViewSelectionSet) {
                "&lt;EntrySelectedBy&gt;"
                    if ($ViewCondition) {
                        "&lt;SelectionCondition&gt;"
                    }
                    if ($ViewTypeName) {
                        "&lt;TypeName&gt;$([Security.SecurityElement]::Escape($ViewTypeName))&lt;/TypeName&gt;"
                    } else {
                        "&lt;SelectionSetName&gt;$([Security.SecurityElement]::Escape($ViewSelectionSet))&lt;/SelectionSetName&gt;"
                    }
                    if ($viewCondition) {
                        "&lt;ScriptBlock&gt;$([Security.SecurityElement]::Escape($viewCondition))&lt;/ScriptBlock&gt;&lt;/SelectionCondition&gt;"
                    }
                "&lt;/EntrySelectedBy&gt;"
            } else {
                ''
            }



$header = @"
    &lt;CustomEntry&gt;
        $entrySelectedBy
        &lt;CustomItem&gt;
            $(
                if ($Frame -or $FirstLineHanging -or $LeftIndent -or $RightIndent -or $FirstLineIndent) {
                    "
                &lt;Frame&gt;
                    $(
                        if ($LeftIndent) { "&lt;LeftIndent&gt;$LeftIndent&lt;/LeftIndent&gt;" }
                        if ($RightIndent) { "&lt;RightIndent&gt;$RightIndent&lt;/RightIndent&gt;" }
                        if ($FirstLineHanging) { "&lt;FirstLineHanging&gt;$FirstLineHanging&lt;/FirstLineHanging&gt;" }
                        if ($FirstLineIndent) { "&lt;FirstLineIndent&gt;$FirstLineIndent&lt;/FirstLineIndent&gt;" }
                    )
                    &lt;CustomItem&gt;
                "
                }
            )            

"@

$footer = @"
$(    
    if ($Frame -or $FirstLineHanging -or $LeftIndent -or $RightIndent -or $FirstLineIndent) {
        "&lt;/CustomItem&gt;&lt;/Frame&gt;"
    }    
)
        &lt;/CustomItem&gt;
    &lt;/CustomEntry&gt;
"@


            $c =0
            $middle = foreach ($sb in $Action) {
                $VisibilityXml =""
                if ("$($VisibilityCondition[$c])") {
                    $VisibilityXml = "&lt;ItemSelectionCondition&gt;&lt;ScriptBlock&gt;
$([Security.SecurityElement]::Escape($VisibilityCondition[$c]))
&lt;/ScriptBlock&gt;&lt;/ItemSelectionCondition&gt;"
                }
                $c++
                $tokens = @([Management.Automation.PSParser]::Tokenize($sb, [ref]$null) |
                    Where-Object { "Comment", "NewLine" -notcontains $_.Type })
                Write-Verbose "$($tokens | Out-String)"
                if ($tokens.Count -eq 1) {
                    if ($tokens[0].Type -eq "Command" -and $tokens[0].Content -ieq "Write-Newline") {
                        "&lt;NewLine /&gt;"
                    } elseif ($tokens[0].Type -eq "String") {
                        $content = $tokens[0].Content
                        # If the expanded size is the same as the original size, then the string most likely didn't
                        # contain expansion, and we can write out a text field instead
                        if (-not ($content.Contains('$'))) {
                            "&lt;Text&gt;$([Security.SecurityElement]::Escape($content))&lt;/Text&gt;"
                        } else {
                            "&lt;ExpressionBinding&gt;
                                $VisibilityXml
                                &lt;ScriptBlock&gt;`"$([Security.SecurityElement]::Escape($content))`"&lt;/ScriptBlock&gt;
                            &lt;/ExpressionBinding&gt;"
                        }
                    } else {
                        "&lt;ExpressionBinding&gt;
                            $VisibilityXml
                            &lt;ScriptBlock&gt;$([Security.SecurityElement]::Escape($sb))&lt;/ScriptBlock&gt;
                        &lt;/ExpressionBinding&gt;"
                    }
                } elseif ($tokens[0].Type -eq "Command" -and 'Show-CustomAction','Write-FormatViewExpression' -contains $tokens[0].Content) {
                    &amp; $MyInvocation.MyCommand.ScriptBlock.Module $sb
                } else {
                    "&lt;ExpressionBinding&gt;
                        $VisibilityXml
                        &lt;ScriptBlock&gt;$([Security.SecurityElement]::Escape($sb))&lt;/ScriptBlock&gt;
                    &lt;/ExpressionBinding&gt;"
                }
            }
                
        $entries += ( $header + $middle + $footer)
    }

    end {
        $viewXml =
            if (-not $AsControl) {
                "&lt;CustomControl&gt;&lt;CustomEntries&gt;" + ($entries -join [Environment]::NewLine) + "&lt;/CustomEntries&gt;&lt;/CustomControl&gt;"
            } else {
                if (-not $Name) {
                    Write-Error "Custom Controls must be named"
                    return
                }

                "&lt;Control&gt;&lt;Name&gt;$Name&lt;/Name&gt;&lt;CustomControl&gt;&lt;CustomEntries&gt;" +
                    $($entries -join [Environment]::NewLine) +
                "&lt;/CustomEntries&gt;&lt;/CustomControl&gt;&lt;/Control&gt;"
            }

        $xml = [xml]$viewXml
        if (-not $xml) { return }
        $xOut=[IO.StringWriter]::new()
        $xml.Save($xOut)
        "$xOut".Substring('&lt;?xml version="1.0" encoding="utf-16"?&gt;'.Length + [Environment]::NewLine.Length)
        $xOut.Dispose()

    }

                    </Script>
      </ScriptMethod>
      <ScriptMethod>
        <Name>Write-FormatListView</Name>
        <Script>
                        
    &lt;#
    .Synopsis
        Writes a view for Format-List
    .Description
        Writes the XML for a PowerShell Format ListControl
    .Link
        Write-FormatView
    .Example
        Write-FormatListView -Property N
    #&gt;
    param(
    # The list of properties to display.
    [Parameter(Mandatory=$true,ValueFromPipelineByPropertyName=$true)]
    [String[]]$Property,

    # If set, will rename the properties in the table.
    # The oldname is the name of the old property, and value is either the new header
    [Parameter(ValueFromPipelineByPropertyName=$true)]
    [Alias('RenamedProperty', 'RenameProperty')]
    [ValidateScript({
        foreach ($kv in $_.GetEnumerator()) {
            if ($kv.Key -isnot [string] -or $kv.Value -isnot [string]) {
                throw "All keys and values in the property rename map must be strings"
            }
        }
        return $true
    })]
    [Collections.IDictionary]$AliasProperty,

    # If set, will create a number of virtual properties within a table
    [Parameter(ValueFromPipelineByPropertyName=$true)]
    [ValidateScript({
        foreach ($kv in $_.GetEnumerator()) {
            if ($kv.Key -isnot [string] -or $kv.Value -isnot [ScriptBlock]) {
                throw "May only contain property names and script blocks"
            }
        }
        return $true
    })]
    [Collections.IDictionary]$VirtualProperty = @{},

    # If set, will be used to format the value of a property.
    [Parameter(Position=4,ValueFromPipelineByPropertyName=$true)]
    [ValidateScript({
        foreach ($kv in $_.GetEnumerator()) {
            if ($kv.Key -isnot [string] -or $kv.Value -isnot [string]) {
                throw "The FormatProperty parameter must contain only strings"
            }
        }
        return $true
    })]
    [Collections.IDictionary]$FormatProperty,

    # If provided, will conditionally color the property.
    # This will add colorization in the hosts that support it, and act normally in hosts that do not.
    # The key is the name of the property.  The value is a script block that may return one or two colors as strings.
    # The color strings may be ANSI escape codes or two hexadecimal colors (the foreground color and the background color)
    [Parameter(ValueFromPipelineByPropertyName=$true)]
    [ValidateScript({
        foreach ($kv in $_.GetEnumerator()) {
            if ($kv.Key -isnot [string] -or $kv.Value -isnot [ScriptBlock]) {
                throw "May only contain property names and script blocks"
            }
        }
        return $true
    })]
    [Alias('ColourProperty')]
    [Collections.IDictionary]$ColorProperty,

    # If provided, will use $psStyle to style the property.
    # # This will add colorization in the hosts that support it, and act normally in hosts that do not.
    # The key is the name of the property.  The value is a script block that may return one or more $psStyle property names.
    [Parameter(ValueFromPipelineByPropertyName)]
    [Collections.IDictionary]$StyleProperty,

    # If provided, will only display a property if the condition is met.
    [Parameter(ValueFromPipelineByPropertyName=$true)]
    [ValidateScript({
        foreach ($kv in $_.GetEnumerator()) {
            if ($kv.Key -isnot [string] -or $kv.Value -isnot [ScriptBlock]) {
                throw "May only contain property names and script blocks"
            }
        }
        return $true
    })]
    [Collections.IDictionary]$ConditionalProperty,

    # If provided, the view will only be used if the the typename includes this value.
    # This is distinct from the overall typename, and can be used to have different views for different inherited objects.
    [Parameter(ValueFromPipelineByPropertyName=$true)]
    [string]
    $ViewTypeName,

    # If provided, the view will only be used if the the typename is in a SelectionSet.
    # This is distinct from the overall typename, and can be used to have different views for different inherited objects.
    [Parameter(ValueFromPipelineByPropertyName=$true)]
    [string]
    $ViewSelectionSet,

    # If provided, will use this entire view if this condition returns a value.
    # More than one view must be provided via the pipeline for this to work,
    # and at least one of these views must not havea condition.
    [Parameter(ValueFromPipelineByPropertyName=$true)]
    [ScriptBlock]
    $ViewCondition
    )

    begin {
        $listEntries = @()

        filter EmbedColorValue {
            if ($_ -is [scriptblock]) { "`$(`$__ = `$_;. {$($_)};`$_ = `$__))"}
            else { "'$($_)'" }
        }
    }

    process {
        $listItems =
            @(for ($i =0; $i -lt $property.Count; $i++) {
                $p = $property[$i]

                $format =
                    if ($FormatProperty.$p) {
                        "&lt;FormatString&gt;$($FormatProperty.$p)&lt;/FormatString&gt;"
                    } else { '' }


                if ($ColorProperty.$p -or $StyleProperty.$p) {
                    $existingScript =
                        if ($VirtualProperty.$p) {
                            $VirtualProperty.$p
                        }
                        elseif ($AliasProperty.$p) {
                            "`$_.'$($AliasProperty.$p.Replace("'","''"))'"
                        } else {
                            "`$_.'$($p.Replace("'","''"))'"
                        }

                    $interpretCellStyle =
                        if ($ColorRow -or $ColorProperty.$p) {
                            {
                            if ($CellColorValue -and $CellColorValue -is [string]) {
                                $CellColorValue = Format-RichText -NoClear -ForegroundColor $CellColorValue
                            } elseif (`$CellColorValue -is [Collections.IDictionary]) {
                                $CellColorValue = Format-RichText -NoClear @CellColorValue
                            }
                            }
                        }
                        elseif ($StyleRow -or $StyleProperty.$p) {
                            {
                            $CellColorValue = if ($psStyle) {
                                @(foreach ($styleProp in $CellColorValue) {
                                    if ($styleProp -match '^\$') {
                                        $ExecutionContext.SessionState.InvokeCommand.InvokeScript($styleProp)
                                    }
                                    elseif ($styleProp -match '\.') {
                                        $targetObject = $psStyle
                                        foreach ($dotProperty in $styleProp -split '(?&lt;!\.)\.') {
                                            if (
                                                ($targetObject.psobject.Members['Item'] -and 
                                                    ($targetObject.Item -is [Management.Automation.PSMethodInfo])
                                                ) -or 
                                                $targetObject -is [Collections.IDictionary]
                                            ) {
                                                $targetObject = $targetObject[$dotProperty]
                                            } else {
                                                $targetObject = $targetObject.$dotProperty
                                            }
                                        }
                                        if ($targetObject) {
                                            $targetObject
                                        }
                                    }
                                    else {
                                        $psStyle.$styleProp
                                    }
                                }) -join ''
                            }
                            }
                        }

                    $ColorizerInfo = if ($ColorProperty.$p) {
                        $ColorProperty.$p | EmbedColorValue
                        
                    }
                    elseif ($StyleProperty.$p) {
                        $StyleProperty.$p | EmbedColorValue                        
                    }

                    $cellResetScript = 
                        if ($ColorRow -or $ColorProperty.$p) {
                            'Format-RichText'                        
                        }
                        elseif ($StyleRow -or $StyleProperty.$p) {
                            '$psStyle.Reset'
                        }

                    $colorizedScript =
                        "                        
                        `$CellColorValue = $ColorizerInfo
                        $InterpretCellStyle                        
                        `$output = . {$existingScript}
                        @(`$CellColorValue; `$output; $cellResetScript) -join ''
                        "
                    
                    
                    $VirtualProperty.$p = $colorizedScript
                }
                &lt;#
                if ($ColorProperty.$p) {
                    $existingScript =
                        if ($VirtualProperty.$p) {
                            $VirtualProperty.$p
                        }
                        elseif ($AliasProperty.$p) {
                            "`$_.'$($AliasProperty.$p.Replace("'","''"))'"
                        } else {
                            "`$_.'$($p.Replace("'","''"))'"
                        }
                    $colorizedScript = "
                `$__ = `$_
                `$ci = . {$($ColorProperty.$p)}
                `$_ = `$__
                if (`$ci -is [string]) {
                    `$ci = Format-RichText -NoClear -ForegroundColor `$ci
                } else {                    
                    `$ci = Format-RichText -NoClear @ci
                }
                `$output = . {" + $existingScript + '}
                @($ci; $output; Format-RichText) -join ""
                '
                    $VirtualProperty.$p = $colorizedScript
                }
                #&gt;

                if ($ColorProperty.$p) {
                    "&lt;!-- {ConditionalColor:`"$([Security.SecurityElement]::Escape($ColorProperty.$p))`"}--&gt;"
                }
                if ($StyleProperty.$p) {
                    "&lt;!-- {ConditionalStyle:`"$([Security.SecurityElement]::Escape($StyleProperty.$p))`"}--&gt;"
                }
                $propCondition = if ($ConditionalProperty.$p) {
                    "&lt;ItemSelectionCondition&gt;&lt;ScriptBlock&gt;$([Security.SecurityElement]::Escape($ConditionalProperty.$p))&lt;/ScriptBlock&gt;&lt;/ItemSelectionCondition&gt;"
                }
                
                $label = "&lt;Label&gt;$([Security.SecurityElement]::Escape($p))&lt;/Label&gt;"
                # If there was an alias defined for this property, use it
                if ($AliasProperty.$p -or $VirtualProperty.$p) {                
                    if ($VirtualProperty.$p) {
                        "&lt;ListItem&gt;$propCondition $label&lt;ScriptBlock&gt;$([Security.SecurityElement]::Escape($VirtualProperty.$p))&lt;/ScriptBlock&gt;$format&lt;/ListItem&gt;"
                    } else {
                        "&lt;ListItem&gt;$propCondition $label&lt;PropertyName&gt;$($AliasProperty.$p)&lt;/PropertyName&gt;$Format&lt;/ListItem&gt;"
                    }
                } else {
                    "&lt;ListItem&gt;$propCondition $label&lt;PropertyName&gt;$p&lt;/PropertyName&gt;$Format&lt;/ListItem&gt;"
                }
            })

        $listEntries += @(
            "&lt;ListEntry&gt;"
            if ($ViewTypeName -or $ViewSelectionSet) {
                "&lt;EntrySelectedBy&gt;"
                    if ($ViewCondition) {
                        "&lt;SelectionCondition&gt;"
                    }
                    if ($ViewTypeName) {
                        "&lt;TypeName&gt;$([Security.SecurityElement]::Escape($ViewTypeName))&lt;/TypeName&gt;"
                    } else {
                        "&lt;SelectionSetName&gt;$([Security.SecurityElement]::Escape($ViewSelectionSet))&lt;/SelectionSetName&gt;"
                    }
                    if ($viewCondition) {
                        "&lt;ScriptBlock&gt;$([Security.SecurityElement]::Escape($viewCondition))&lt;/ScriptBlock&gt;&lt;/SelectionCondition&gt;"
                    }
                "&lt;/EntrySelectedBy&gt;"
            }
            "&lt;ListItems&gt;"
            $listitems
            "&lt;/ListItems&gt;&lt;/ListEntry&gt;"
        ) -join ''
    }


    end {
        $thelistControl= @(
            '&lt;ListControl&gt;'
            '&lt;ListEntries&gt;'
            $listEntries
            '&lt;/ListEntries&gt;'
            '&lt;/ListControl&gt;'
        ) -join ''

        $xml=[xml]$thelistControl
        if (-not $xml) { return }
        $xOut=[IO.StringWriter]::new()
        $xml.Save($xOut)
        "$xOut".Substring('&lt;?xml version="1.0" encoding="utf-16"?&gt;'.Length + [Environment]::NewLine.Length)
        $xOut.Dispose()
    }

                    </Script>
      </ScriptMethod>
      <ScriptMethod>
        <Name>Write-FormatSelectionCondition</Name>
        <Script>
                        
    &lt;#
    .SYNOPSIS
        Writes a selection condition.
    .DESCRIPTION
        Writes a formatting selection condition.
    .NOTES    
        PowerShell formatting can be conditional.

        A condition is expressed an `&lt;SelectionCondition&gt;` element, which must be inside of an `&lt;EntrySelectedBy&gt;` element..

        Multiple selection conditions are permitted in a single `&lt;EntrySelectedBy&gt;` element.  
        
        They will be evaluated using `-or` (if any of the conditions is true, the formatting will be applied).
    #&gt;
    param(
    # The type name of the selection set.
    [Parameter(ValueFromPipelineByPropertyName)]    
    [string]
    $TypeName,

    # The name of the selection set.
    [Parameter(ValueFromPipelineByPropertyName)]
    [string]
    $SelectionSet,

    # The type names in the selection set.    
    [Alias('SelectionCondition')]
    [ScriptBlock]
    $ScriptBlock
    )

    begin {
        # First, create a queue to hold the selection conditions
        $selectionConditionQueue = [Collections.Queue]::new()
    }
    
    process {
        # Each selection condition is a separate XML element
        $selectionConditionXml = [xml](@(
            "&lt;SelectionCondition&gt;"
                # Consisting of a typename
                if ($TypeName) {
                    if (-not ("&lt;TypeName&gt;$TypeName&lt;/TypeName&gt;" -as [xml])) {
                        "&lt;TypeName&gt;$([Security.SecurityElement]::Escape($TypeName))&lt;/TypeName&gt;"
                    } else {
                        "&lt;TypeName&gt;$TypeName&lt;/TypeName&gt;"
                    }
                }
                # or a selection set name
                elseif ($SelectionSet) {
                    if (-not ("&lt;SelectionSetName&gt;$SelectionSet&lt;/SelectionSetName&gt;" -as [xml])) {
                        "&lt;SelectionSetName&gt;$([Security.SecurityElement]::Escape($SelectionSet))&lt;/SelectionSetName&gt;"
                    } else {
                        "&lt;SelectionSetName&gt;$SelectionSet&lt;/SelectionSetName&gt;"
                    }
                }
                # and a script block.
                # If no `-ScriptBlock` is provided,
                if (-not $ScriptBlock) {
                    # it is assumed to be `$true`.
                    "&lt;ScriptBlock&gt;`$true&lt;/ScriptBlock&gt;"
                } else {
                    "&lt;ScriptBlock&gt;$([Security.SecurityElement]::Escape($ScriptBlock))&lt;/ScriptBlock&gt;"
                }
            "&lt;/SelectionCondition&gt;"
        ) -join '')
        if (-not $selectionConditionXml) { return }
        # Save the XML to a string (for readablility),
        $xOut=[IO.StringWriter]::new()
        $selectionConditionXml.Save($xOut)
        # and add the string to the queue (remove the XML declaration).
        $selectionConditionQueue.Enqueue("$xOut" -replace '\&lt;\?xml.+?\?&gt;[\s\r\n]+')
        $xOut.Dispose()
    }

    end {
        # Finally, create an `&lt;EntrySelectedBy&gt;` element
        $EntrySelectedByXml = @(
            "&lt;EntrySelectedBy&gt;"
            # containing all of the selection conditions
            $selectionConditionQueue.ToArray()
            "&lt;/EntrySelectedBy&gt;"
        ) -join '' -as [xml]
        # Save the XML to a string (for readablility),
        $xOut=[IO.StringWriter]::new()
        $EntrySelectedByXml.Save($xOut)
        # and return the string (remove the XML declaration).
        "$xOut" -replace '\&lt;\?xml.+?\?&gt;[\s\r\n]+'
        $xOut.Dispose()
    }

                    </Script>
      </ScriptMethod>
      <ScriptMethod>
        <Name>Write-FormatSelectionSet</Name>
        <Script>
                        
    &lt;#
    .SYNOPSIS
        Writes a selection set.
    .DESCRIPTION
        Writes a format selection set.
    .NOTES    
        Formatting is commonly selected by a TypeName.
        
        It can also be selected by a group of type names, which is called a SelectionSet.

        A few built-in formatters use selection sets, most notably the filesystem formatters.
    .EXAMPLE
        Write-FormatSelectionSet -Name 'FileSystemTypes' -TypeName 'System.IO.DirectoryInfo', 'System.IO.FileInfo'    
    #&gt;
    param(
    # The name of the selection set.
    [Parameter(Mandatory,ValueFromPipelineByPropertyName)]
    [Alias('SelectionSetName','SelectionSet')]
    [string]
    $Name,

    # The type names in the selection set.
    [Parameter(Mandatory,ValueFromPipelineByPropertyName)]
    [string[]]
    $TypeName
    )

    begin {
        # First, create a queue to hold the selection sets.
        $eachSelectionSet = [Collections.Queue]::new()
    }
    
    process {
        # Make sure the name and type names are XML-safe
        $NameAsXml = "&lt;Name&gt;$Name&lt;/Name&gt;" -as [xml]
        if (-not $NameAsXml) {
            $Name = [Security.SecurityElement]::Escape($Name)
        }
        $TypeName = foreach ($tn in $TypeName) {
            if (-not ("&lt;TypeName&gt;$tn&lt;/TypeName&gt;" -as [xml])) {
                [Security.SecurityElement]::Escape($tn)
            } else {
                $tn
            }
        }

        # Create the selection set XML
        $selectionSetXml = [xml](@(
            "&lt;SelectionSet&gt;"
                # Consisting of a `&lt;Name&gt;`
                "&lt;Name&gt;$Name&lt;/Name&gt;"                
                "&lt;Types&gt;" # and a `&lt;Types&gt;` element
                    foreach ($tn in $TypeName) {
                        # (containing each `&lt;TypeName&gt;`)
                        "&lt;TypeName&gt;$tn&lt;/TypeName&gt;"
                    }
                "&lt;/Types&gt;"
            "&lt;/SelectionSet&gt;"
        ) -join '')
        if (-not $selectionSetXml) { return }
        $xOut=[IO.StringWriter]::new()
        $selectionSetXml.Save($xOut)
        $eachSelectionSet.Enqueue("$xOut" -replace '\&lt;\?xml.+?\?&gt;[\s\r\n]+')
        $xOut.Dispose()
    }

    end {
        # Create the `&lt;SelectionSets&gt;` element
        $selectionSetXml = @(
            "&lt;SelectionSets&gt;"
            # (containing each `&lt;SelectionSet&gt;`)
            $eachSelectionSet.ToArray()
            "&lt;/SelectionSets&gt;"
        ) -join '' -as [xml]
        $xOut=[IO.StringWriter]::new()
        $selectionSetXml.Save($xOut)
        # Write the XML to the pipeline as a string, removing the XML declaration.
        "$xOut" -replace '\&lt;\?xml.+?\?&gt;[\s\r\n]+'
        $xOut.Dispose()
    }

                    </Script>
      </ScriptMethod>
      <ScriptMethod>
        <Name>Write-FormatTableView</Name>
        <Script>
                        
    &lt;#
    .Synopsis
        Writes a view for Format-Table
    .Description
        Writes the XML for a PowerShell Format TableControl.
    .Example
        Write-FormatTableView -Property myFirstProperty,mySecondProperty -TypeName MyPropertyBag
    .Example
        Write-FormatTableView -Property "Friendly Property Name" -RenameProperty @{
            "Friendly Property Name" = 'SystemName'
        }
    .Example
        Write-FormatTableView -Property Name, Bio -Width 20 -Wrap
    .Example
        Write-FormatTableView -Property Number, IsEven, IsOdd -AutoSize -ColorRow {if ($_.N % 2) { "#ff0000"} else {"#0f0"} } -VirtualProperty @{
            IsEven = { -not ($_.N % 2)}
            IsOdd = { ($_.N % 2) -as [bool] }
        } -AliasProperty @{
            Number = 'N'
        }
    .Link
        Write-FormatView
    #&gt;
    [OutputType([string])]
    param(
    # The list of properties to display.
    [Parameter(Mandatory=$true,Position=0,ValueFromPipelineByPropertyName=$true)]
    [String[]]$Property,

    # If set, will rename the properties in the table.
    # The oldname is the name of the old property, and value is either the new header
    [Parameter(ValueFromPipelineByPropertyName=$true)]
    [Alias('RenamedProperty', 'RenameProperty')]
    [ValidateScript({
        foreach ($kv in $_.GetEnumerator()) {
            if ($kv.Key -isnot [string] -or $kv.Value -isnot [string]) {
                throw "All keys and values in the property rename map must be strings"
            }
        }
        return $true
    })]
    [Collections.IDictionary]$AliasProperty,

    # If set, will create a number of virtual properties within a table
    [Parameter(ValueFromPipelineByPropertyName=$true)]
    [ValidateScript({
        foreach ($kv in $_.GetEnumerator()) {
            if ($kv.Key -isnot [string] -or $kv.Value -isnot [ScriptBlock]) {
                throw "May only contain property names and script blocks"
            }
        }
        return $true
    })]
    [Collections.IDictionary]$VirtualProperty = @{},

    # If set, will be used to format the value of a property.
    [Parameter(Position=4,ValueFromPipelineByPropertyName=$true)]
    [ValidateScript({
        foreach ($kv in $_.GetEnumerator()) {
            if ($kv.Key -isnot [string] -or $kv.Value -isnot [string]) {
                throw "The FormatProperty parameter must contain only strings"
            }
        }
        return $true
    })]
    [Collections.IDictionary]$FormatProperty,


    # If provided, will set the alignment used to display a given property.
    [Parameter(ValueFromPipelineByPropertyName=$true)]
    [ValidateScript({
        foreach ($kv in $_.GetEnumerator()) {
            if ($kv.Key -isnot [string] -or 'left', 'right', 'center' -notcontains $kv.Value) {
                throw 'The alignment property may only contain property names and the values: left, right, and center'
            }
        }
        return $true
    })]
    [Collections.IDictionary]$AlignProperty,

    # If provided, will conditionally color the property.
    # This will add colorization in the hosts that support it, and act normally in hosts that do not.
    # The key is the name of the property.  The value is a script block that may return one or two colors as strings.
    # The color strings may be ANSI escape codes or two hexadecimal colors (the foreground color and the background color)
    [Parameter(ValueFromPipelineByPropertyName=$true)]
    [ValidateScript({
        foreach ($kv in $_.GetEnumerator()) {
            if ($kv.Key -isnot [string] -or $kv.Value -isnot [ScriptBlock]) {
                throw "May only contain property names and script blocks"
            }
        }
        return $true
    })]
    [Alias('ColourProperty')]
    [Collections.IDictionary]$ColorProperty,

    # If provided, will use $psStyle to style the property.
    # # This will add colorization in the hosts that support it, and act normally in hosts that do not.
    # The key is the name of the property.  The value is a script block that may return one or more $psStyle property names.
    [Parameter(ValueFromPipelineByPropertyName)]
    [Collections.IDictionary]$StyleProperty,

    # If provided, will colorize all rows in a table, according to the script block.
    # If the script block returns a value, it will be treated either as an ANSI escape sequence or up to two hexadecimal colors
    [Parameter(ValueFromPipelineByPropertyName)]
    [Alias('ColourRow')]
    [ScriptBlock]$ColorRow,

    # If provided, will style all rows in a table, according to the script block.
    # If the script block returns a value, it will be treated as a value on $PSStyle.
    [Parameter(ValueFromPipelineByPropertyName)]
    [ScriptBlock]$StyleRow,

    # If set, the table will be autosized.
    [switch]
    $AutoSize,

    # If set, the table headers will not be displayed.
    [Alias('HideTableHeaders','HideTableHeader')]
    [switch]
    $HideHeader,

    # The width of any the properties.  This parameter is optional, and cannot be used with -AutoSize.
    # A negative width is a right justified table.
    # A positive width is a left justified table
    # A width of 0 will not include an alignment hint.
    [ValidateRange(-100,100)]
    [Parameter(ValueFromPipelineByPropertyName=$true)]
    [int[]]$Width,

     # If wrap is set, then items in the table can span multiple lines
    [Parameter(ValueFromPipelineByPropertyName=$true)]
    [switch]$Wrap,

    # If provided, the table view will only be used if the the typename includes this value.
    # This is distinct from the overall typename, and can be used to have different table views for different inherited objects.
    [Parameter(ValueFromPipelineByPropertyName)]
    [string]
    $ViewTypeName,

    # If provided, the table view will only be used if the the typename is in a SelectionSet.
    # This is distinct from the overall typename, and can be used to have different table views for different inherited objects.
    [Parameter(ValueFromPipelineByPropertyName)]
    [string]
    $ViewSelectionSet,

    # If provided, will selectively display items.
    [Parameter(ValueFromPipelineByPropertyName)]
    [ScriptBlock]
    $ViewCondition
    )

    begin {
        $rowEntries = @()

        filter EmbedColorValue {
            if ($_ -is [scriptblock]) { "`$(`$Script:_LastCellStyle = `$(`$__ = `$_;. {$($_)};`$_ = `$__);`$Script:_LastCellStyle)"}
            else { "`$(`$Script:_LastCellStyle ='$($_)';`$Script:_LastCellStyle)" }
        }

        $myParameterNames = @(($MyInvocation.MyCommand -as [Management.Automation.CommandMetadata]).Keys) -as [string[]]
    }

    process {
        # ValueFromPipelineByPropertyName is great, but it is "sticky".
        # Parameters that have been bound aren't "unbound" until a new value is provided.
        # This means that if a parameter is not provided, it will keep the last value.
        # And that's what we call an unexpected side effect.
        # In order to avoid this, we walk over our list of parameter names
        foreach ($parameterName in $myParameterNames) {
            # if they are not in the bound parameters
            if (-not $PSBoundParameters.ContainsKey($parameterName)) {
                # we nullify them
                try { $ExecutionContext.SessionState.PSVariable.Set($parameterName, $null) }
                # and if we can't, we write a verbose message.
                catch { Write-Verbose "Could not nullify '$parameterName': $_ " }
            }
        }
        $tableHeader = ''
        $rowColumns =
            @(for ($i =0; $i -lt $property.Count; $i++) {
                $p = $property[$i]
                if ($Width -and $Width[$i]) {
                    if ($Width[$i] -lt 0) {
                        $widthTag = "&lt;Width&gt;$([Math]::Abs($Width[$i]))&lt;/Width&gt;"
                        $alignment = "&lt;Alignment&gt;right&lt;/Alignment&gt;"
                    } else {
                        $widthTag = "&lt;Width&gt;$([Math]::Abs($Width[$i]))&lt;/Width&gt;"
                        $alignment = "&lt;Alignment&gt;left&lt;/Alignment&gt;"
                    }
                } else {
                    $widthTag = ''
                }

                if ($AlignProperty.$p) {
                    $alignment = "&lt;Alignment&gt;$($AlignProperty.$p)&lt;/Alignment&gt;"
                }

                $format =
                    if ($FormatProperty.$p) {
                        "&lt;FormatString&gt;$($FormatProperty.$p)&lt;/FormatString&gt;"
                    } else { '' }


                if ($ColorProperty.$p -or $ColorRow -or $StyleProperty.$p -or $StyleRow) {
                    $existingScript =
                        if ($VirtualProperty.$p) {
                            $VirtualProperty.$p
                        }
                        elseif ($AliasProperty.$p) {
                            "`$_.'$($AliasProperty.$p.Replace("'","''"))'"
                        } else {
                            "`$_.'$($p.Replace("'","''"))'"
                        }

                    $interpretCellStyle =
                        if ($ColorRow -or $ColorProperty.$p) {
                            {
                            if ($CellColorValue -and $CellColorValue -is [string]) {
                                $CellColorValue = Format-RichText -NoClear -ForegroundColor $CellColorValue
                            } elseif (`$CellColorValue -is [Collections.IDictionary]) {
                                $CellColorValue = Format-RichText -NoClear @CellColorValue
                            }
                            }
                        }
                        elseif ($StyleRow -or $StyleProperty.$p) {
                            {
                            $CellColorValue = if ($psStyle) {
                                @(foreach ($styleProp in $CellColorValue) {
                                    if ($styleProp -match '^\$') {
                                        $ExecutionContext.SessionState.InvokeCommand.InvokeScript($styleProp)
                                    }
                                    elseif ($styleProp -match '\.') {
                                        $targetObject = $psStyle
                                        foreach ($dotProperty in $styleProp -split '(?&lt;!\.)\.') {
                                            if (
                                                ($targetObject.psobject.Members['Item'] -and 
                                                    ($targetObject.Item -is [Management.Automation.PSMethodInfo])
                                                ) -or 
                                                $targetObject -is [Collections.IDictionary]
                                            ) {
                                                $targetObject = $targetObject[$dotProperty]
                                            } else {
                                                $targetObject = $targetObject.$dotProperty
                                            }
                                        }
                                        if ($targetObject) {
                                            $targetObject
                                        }
                                    }
                                    else {
                                        $psStyle.$styleProp
                                    }
                                }) -join ''
                            }
                            }
                        }

                    $ColorizerInfo = if ($ColorRow) {
                        if ($i -eq 0) {
                            $ColorRow | EmbedColorValue                            
                        } else {
                            '$Script:_LastCellStyle'
                        }                        
                    } elseif ($StyleRow) {
                        if ($i -eq 0) {
                            $styleRow | EmbedColorValue
                        } else {
                            '$Script:_LastCellStyle'
                        }                        
                    }
                    elseif ($ColorProperty.$p) {
                        $ColorProperty.$p | EmbedColorValue
                        
                    }
                    elseif ($StyleProperty.$p) {
                        $StyleProperty.$p | EmbedColorValue                        
                    }

                    $cellResetScript = 
                        if ($ColorRow -or $ColorProperty.$p) {
                            'Format-RichText'                        
                        }
                        elseif ($StyleRow -or $StyleProperty.$p) {
                            '$psStyle.Reset'
                        }

                    $colorizedScript =
                        "                        
                        `$CellColorValue = $ColorizerInfo
                        $InterpretCellStyle                        
                        `$output = . {$existingScript}
                        @(`$CellColorValue; `$output; $cellResetScript) -join ''
                        "
                    
                    
                    $VirtualProperty.$p = $colorizedScript
                }

                if ($ColorProperty.$p) {
                    "&lt;!-- {ConditionalColor:`"$([Security.SecurityElement]::Escape($ColorProperty.$p))`"}--&gt;"
                }
                if ($StyleProperty.$p) {
                    "&lt;!-- {ConditionalStyle:`"$([Security.SecurityElement]::Escape($StyleProperty.$p))`"}--&gt;"
                }
                $label = "&lt;Label&gt;$([Security.SecurityElement]::Escape($p))&lt;/Label&gt;"
                # If there was an alias defined for this property, use it                
                if ($AliasProperty.$p -or $VirtualProperty.$p) {                    
                    if ($VirtualProperty.$p) {
                        "&lt;TableColumnItem&gt;&lt;ScriptBlock&gt;$([Security.SecurityElement]::Escape($VirtualProperty.$p))&lt;/ScriptBlock&gt;$format&lt;/TableColumnItem&gt;"
                    } else {
                        "&lt;TableColumnItem&gt;&lt;PropertyName&gt;$($AliasProperty.$p)&lt;/PropertyName&gt;$Format&lt;/TableColumnItem&gt;"
                    }
                } else {
                    "&lt;TableColumnItem&gt;&lt;PropertyName&gt;$p&lt;/PropertyName&gt;$Format&lt;/TableColumnItem&gt;"
                }
                $TableHeader += "&lt;TableColumnHeader&gt;${Label}${alignment}${WidthTag}&lt;/TableColumnHeader&gt;"
            })

        $rowEntries += @(
            if ($ColorRow) {
                "&lt;!-- {ConditionalColor:`"$([Security.SecurityElement]::Escape($ColorRow))`"}--&gt;"
            }
            "&lt;TableRowEntry&gt;"
            $(if ($Wrap) { "&lt;Wrap/&gt;" })
            if ($PSBoundParameters.ViewTypeName -or $PSBoundParameters.ViewSelectionSet) {
                "&lt;EntrySelectedBy&gt;"
                    if ($ViewCondition) {
                        "&lt;SelectionCondition&gt;"
                    }
                    if ($ViewTypeName) {
                        "&lt;TypeName&gt;$([Security.SecurityElement]::Escape($ViewTypeName))&lt;/TypeName&gt;"
                    } else {
                        "&lt;SelectionSetName&gt;$([Security.SecurityElement]::Escape($ViewSelectionSet))&lt;/SelectionSetName&gt;"
                    }
                    if ($viewCondition) {
                        "&lt;ScriptBlock&gt;$([Security.SecurityElement]::Escape($viewCondition))&lt;/ScriptBlock&gt;&lt;/SelectionCondition&gt;"
                    }
                "&lt;/EntrySelectedBy&gt;"
            }
            "&lt;TableColumnItems&gt;"
            $rowColumns
            "&lt;/TableColumnItems&gt;&lt;/TableRowEntry&gt;"
        ) -join ''
    }
    end {
        $theTableControl = @(
            '&lt;TableControl&gt;'
            if ($AutoSize) {'&lt;AutoSize/&gt;'}
            if ($HideHeader) {'&lt;HideTableHeaders/&gt;'}
            '&lt;TableHeaders&gt;'
            $tableHeader
            '&lt;/TableHeaders&gt;'
            '&lt;TableRowEntries&gt;'
            $rowEntries
            '&lt;/TableRowEntries&gt;'
            '&lt;/TableControl&gt;'
        ) -join ''

        $xml=[xml]$theTableControl
        if (-not $xml) { return }
        $xOut=[IO.StringWriter]::new()
        $xml.Save($xOut)
        "$xOut".Substring('&lt;?xml version="1.0" encoding="utf-16"?&gt;'.Length + [Environment]::NewLine.Length)
        $xOut.Dispose()
    }

                    </Script>
      </ScriptMethod>
      <ScriptMethod>
        <Name>Write-FormatTreeView</Name>
        <Script>
                        
    &lt;#
    .Synopsis
        Writes the format XML for a TreeView
    .Description
        Writes the .format.ps1xml fragement for a tree view, or a tree node.
    .Link
        Write-FormatCustomView
    .Link
        Write-FormatViewExpression
    .Example
        Write-FormatTreeView -TypeName System.IO.FileInfo, System.IO.DirectoryInfo -NodeProperty Name -HasChildren {
            if (-not $_.EnumerateFiles) { return $false }
            foreach ($f in $_.EnumerateFiles()) {$f;break}
        },
        {
            if (-not $_.EnumerateDirectories) { return $false }
            foreach ($f in $_.EnumerateDirectories()) {$f;break}
        } -Children {
            $_.EnumerateFiles()
        }, {
            foreach ($d in $_.EnumerateDirectories()) {
                if ($d.Attributes -band 'Hidden') { continue }
                $d
            }
        } -Branch ('' + [char]9500 + [char]9472 + [char]9472) -Trunk '|  ' |
            Out-FormatData |
            Add-FormatData

        Get-Module EZOut | Split-Path | Get-Item | Format-Custom
    #&gt;
    param(
    # One or more properties to be displayed.
    [Parameter(ValueFromPipelineByPropertyName)]
    [ValidateScript({
        foreach ($i in $_) {
            if ($i -isnot [string] -and $i -isnot [ScriptBlock] -and $i -isnot [Collections.IDictionary]) {
                throw "Properties must be a [string], [scriptblock], [collections.IDictionary]"
            }
        }
        return $true
    })]
    [Alias('NodeProperty')]
    [PSObject[]]
    $Property,

    # The separator between one or more properties.
    [Parameter(ValueFromPipelineByPropertyName)]
    [string]
    $Separator,


    # The Tree View's branch.
    # This text will be displayed before the node.
    [Parameter(ValueFromPipelineByPropertyName)]
    [string]
    $Branch = '',
    # The Tree View's Trunk.
    # This will be displayed once per depth.
    # By default, this is four blank spaces.
    [Parameter(ValueFromPipelineByPropertyName)]
    [string]
    $Trunk = '    ',

    # One or more type names.
    [Parameter(ValueFromPipelineByPropertyName)]
    [string[]]
    $TypeName,

    # The name of the selection set.  Selection sets are an alternative way to specify a list of types.
    [Parameter(ValueFromPipelineByPropertyName)]
    [Alias('SelectionSetName')]
    [string]
    $SelectionSet,

    # The name of the tree node control.
    # If not provided, this will be Typename1/TypeName2.TreeNode or SelectionSet.TreeNode
    [Parameter(ValueFromPipelineByPropertyName)]
    [string]
    $ControlName,

    # If provided, the table view will only be used if the the typename includes this value.
    # This is distinct from the overall typename, and can be used to have different table views for different inherited objects.
    [Parameter(ValueFromPipelineByPropertyName=$true)]
    [string]
    $ViewTypeName,

    # If provided, the table view will only be used if the the typename is in a SelectionSet.
    # This is distinct from the overall typename, and can be used to have different table views for different inherited objects.
    [Parameter(ValueFromPipelineByPropertyName=$true)]
    [string]
    $ViewSelectionSet,

    # If provided, will selectively display items.
    [Parameter(ValueFromPipelineByPropertyName=$true)]
    [ScriptBlock]
    $ViewCondition,

    # Text displayed at the end of each branch.
    [Parameter(ValueFromPipelineByPropertyName)]
    [string]
    $EndBranch,

    # A script block displayed at the end of each branch.
    [Parameter(ValueFromPipelineByPropertyName)]
    [ScriptBlock]
    $EndBranchScript,

    # A set of script blocks that determine if the node has children.
    # If these script blocks return a value (that is not 0 or $false),
    # then the associated Children scriptblock will be called.
    [Parameter(ValueFromPipelineByPropertyName)]
    [ScriptBlock[]]
    $HasChildren,

    # A set of script blocks to populate the next generation of nodes.
    # By default, the values returned from these script blocks will become child ndoes
    # of the same type of tree control.
    [Parameter(ValueFromPipelineByPropertyName)]
    [ScriptBlock[]]
    $Children,

    # If provided, child nodes will be rendered with a different custom custom control.
    # This control must exist in the same format file.
    [Parameter(ValueFromPipelineByPropertyName)]
    [string[]]
    $ChildNodeControl)


    begin {
        $allOut = @()
    }

    process {
        $allOut += @(
        '&lt;CustomEntry&gt;'
        if ($ViewSelectionSet -or $ViewTypeName) {
            '&lt;EntrySelectedBy&gt;'
            if ($ViewCondition) {
                '&lt;SelectionCondition&gt;'
            }
            if ($ViewTypeName) {
                "&lt;TypeName&gt;$([Security.SecurityElement]::Escape($ViewTypeName))&lt;/TypeName&gt;"
            } elseif ($ViewSelectionSet) {
                "&lt;SelectionSetName&gt;$([Security.SecurityElement]::Escape($ViewSelectionSet))&lt;/SelectionSetName&gt;"
            }
            if ($ViewCondition) {
                if ($viewCondition) {
                    "&lt;ScriptBlock&gt;$([Security.SecurityElement]::Escape($viewCondition))&lt;/ScriptBlock&gt;&lt;/SelectionCondition&gt;"
                }
            }
            '&lt;/EntrySelectedBy&gt;'
        }
        '&lt;CustomItem&gt;'
        Write-FormatViewExpression -ScriptBlock ([ScriptBLock]::Create(@"
`$Branch,`$trunk = '$($Branch.Replace("'","''"))', '$($trunk.Replace("'","''"))'
if (`$script:treeDepth) {
    [Environment]::Newline + (`$trunk * `$script:TreeDepth)+ `$Branch
} else {
    `$Branch
}
`$script:TreeDepth++;
"@))
#

        if ($Property) {
            @(foreach ($p in $Property) {
                if ($p -is [string]) {
                    Write-FormatViewExpression -Property $P
                } elseif ($p -is [ScriptBlock]) {
                    Write-FormatViewExpression -ScriptBlock $p
                } elseif ($p -is [Collections.IDictionary]) {
                    Write-FormatViewExpression @p
                }
            }) -join $(
                if ($Separator) {
                    "&lt;Text&gt;$([Security.SecurityElement]::Escape($Separator))&lt;/Text&gt;"
                } else {
                    ''
                }
            )
        }

        if ($Children) {
            for ($i =0 ;$i -lt $Children.Count;$i++) {
                if ("$($HasChildren[$i])") {
                    $theChildControl = if ($ChildNodeControl) {
                        if ($ChildNodeControl[$i]) {
                            $ChildNodeControl[$i]
                        } else {
                            $ChildNodeControl[-1]
                        }
                    } elseif ($controlName) {
                        $controlName
                    } elseif ($TypeName) {
                        "$($TypeName -join '/').TreeNode"
                    } elseif ($SelectionSet) {
                        "$SelectionSet.TreeNode"
                    }
                    Write-FormatViewExpression -If $HasChildren[$i] -ScriptBlock $Children[$i] -Enumerate -ActionName $theChildControl
                }
            }
        }

        if ($EndBranch) {
            "&lt;Text&gt;$([Security.SecurityElement]::Escape($EndBranch))&lt;/Text&gt;"
        } elseif ($EndBranchScript) {
            Write-FormatViewExpression -ScriptBlock $EndBranchScript
        }

        @'
        &lt;ExpressionBinding&gt;
            &lt;ItemSelectionCondition&gt;&lt;ScriptBlock&gt;$script:TreeDepth--;&lt;/ScriptBlock&gt;&lt;/ItemSelectionCondition&gt;
            &lt;ScriptBlock&gt;$null&lt;/ScriptBlock&gt;
        &lt;/ExpressionBinding&gt;
&lt;/CustomItem&gt;&lt;/CustomEntry&gt;
'@
        )
    }

    end {
        $ControlName = if (-not $ControlName) {
            if ($TypeName) {
                "$($TypeName -join '/').TreeNode"
            } elseif ($SelectionSet) {
                "$SelectionSet.TreeNode"
            }
        } else {
            $ControlName
        }
        if (-not $ControlName) {
            Write-Error "Must Provide a Control Name, TypeName, or SelectionSetName"
            return
        }
        $xmlStr=  @("&lt;Control&gt;&lt;Name&gt;$([Security.SecurityElement]::Escape($ControlName))&lt;/Name&gt;
&lt;CustomControl&gt;
&lt;CustomEntries&gt;
$($allOut -join '')
&lt;/CustomEntries&gt;
&lt;/CustomControl&gt;&lt;/Control&gt;")
        $xml=[xml]$xmlStr
        if (-not $xml) { return }
        $xOut=[IO.StringWriter]::new()
        $xml.Save($xOut)
        "$xOut".Substring('&lt;?xml version="1.0" encoding="utf-16"?&gt;'.Length + [Environment]::NewLine.Length)
        $xOut.Dispose()
        $rootStart = if ($TypeName) {
            "&lt;View&gt;
                &lt;Name&gt;$([Security.SecurityElement]::Escape(($TypeName -join '/')))&lt;/Name&gt;
                &lt;ViewSelectedBy&gt;
                $(foreach ($t in $typename) { "&lt;TypeName&gt;$([Security.SecurityElement]::Escape($t))&lt;/TypeName&gt;"})
                &lt;/ViewSelectedBy&gt;
            "
        } elseif ($SelectionSet) {
            "&lt;View&gt;
                &lt;Name&gt;$($SelectionSet)&lt;/Name&gt;
                &lt;ViewSelectedBy&gt;
                $(foreach ($t in $SelectionSet) { "&lt;SelectionSetName&gt;$([Security.SecurityElement]::Escape($t))&lt;/SelectionSetName&gt;"})
                &lt;/ViewSelectedBy&gt;
            "
        }

        if ($rootStart) {
            $restOfView = $rootStart +  "
&lt;CustomControl&gt;
&lt;CustomEntries&gt;
    &lt;CustomEntry&gt;
        &lt;CustomItem&gt;
            $(Write-FormatViewExpression -If ([ScriptBlock]::Create('$script:TreeDepth = 0;$true')) -ScriptBlock ([ScriptBlock]::Create('$_')) -ActionName $ControlName -Enumerate)
            $(Write-FormatViewExpression -If ([ScriptBlock]::Create('$executionContext.SessionState.PSVariable.Remove("script:TreeDepth");$false')) -ScriptBlock ([ScriptBlock]::Create('$null')))
        &lt;/CustomItem&gt;
    &lt;/CustomEntry&gt;
&lt;/CustomEntries&gt;
&lt;/CustomControl&gt;
&lt;/View&gt;"


            $xml=[xml]$restOfView
            if (-not $xml) { return }
            $xOut=[IO.StringWriter]::new()
            $xml.Save($xOut)
            "$xOut".Substring('&lt;?xml version="1.0" encoding="utf-16"?&gt;'.Length + [Environment]::NewLine.Length)
            $xOut.Dispose()
        }

    }

                    </Script>
      </ScriptMethod>
      <ScriptMethod>
        <Name>Write-FormatView</Name>
        <Script>
                        
    &lt;#
    .Synopsis
        Creates a format XML that will be used to display a type.
    .Description
        Creates a format XML that will be used to display a type.

        Format XML is used by Windows PowerShell to determine how objects are displayed.

        Most items in PowerShell that come from built-in cmdlets make use of formatters in some
        way or another.  Write-FormatView simplifies the creation of formatting for a type.


        You can format information in three major ways in PowerShell:
            - As a table
            - As a list
            - As a custom action

        Write-FormatView supports displaying information in any of these ways.  This display
        will be applied to any information that would be displayed to the user (or piped into
        an Out- cmdlet) that has the typename you specify.  A typename can be anything you like,
        and it can be set in a short piece of PowerShell script:

            $object.psObject.Typenames.Clear()
            $null = $object.psObject.TypeNames.Add("MyTypeName").

        Since it is so simple to change the type names, it's equally simple to make your own way to
        display data, and to write functions that leverage the formatting system in PowerShell to help
        you write the information.  This can streamline your use of PowerShell, and open up many
        new possibilities.
    .Outputs
        [string]
    .Link
        Out-FormatData
    .Link
        Add-FormatData
    .Example
        Write-FormatView -TypeName MyType -Property Property1, Property2
    .Example        
        Write-FormatView -TypeName ColorizedRow -Property Number, IsEven, IsOdd -AutoSize -ColorRow {if ($_.N % 2) { "#ff0000"} else {"#0f0"} } -VirtualProperty @{
            IsEven = { -not ($_.N % 2)}
            IsOdd = { ($_.N % 2) -as [bool] }
        } -AliasProperty @{
            Number = 'N'
        } | 
            Out-FormatData | 
            Add-FormatData

        # Colorized formatting will not work in the ISE
        foreach ($n in 1..5) {
            [PSCustomObject]@{
                PSTypeName='ColorizedRow'
                N = $n
            }
        }
    .Example
        Write-FormatView -TypeName "System.Xml.XmlNode" -Wrap -Property "Xml" -VirtualProperty @{
            "Xml" = {
                $strWrite = New-Object IO.StringWriter
                ([xml]$_.Outerxml).Save($strWrite)
                "$strWrite"
            }
        } |
            Out-FormatData |
            Add-FormatData

        [xml]"&lt;a an='anattribute'&gt;&lt;b d='attribute'&gt;&lt;c /&gt;&lt;/b&gt;&lt;/a&gt;"
    #&gt;
    [CmdletBinding(DefaultParameterSetName="TableView")]
    [OutputType([string])]
    &lt;#=&gt; Write-FormatTreeView -Off 1 -ParameterSet TreeView #&gt;
    &lt;#=&gt; Write-FormatTableView -Off 1 -ParameterSet TableView #&gt;
    &lt;#=&gt; Write-FormatWideView -Off 1 -ParameterSet WideView #&gt;
    &lt;#=&gt; Write-FormatListView -Off 1 -ParameterSet ListView #&gt;
    param(
    # One or more type names.
    [Parameter(Mandatory=$true,ValueFromPipelineByPropertyName=$true,Position=0)]
    [String[]]
    $TypeName,

    # One or more properties to include in the default type view.
    [Parameter(ParameterSetName='TableView',Mandatory=$true,Position=1,ValueFromPipelineByPropertyName=$true)]
    [Parameter(ParameterSetName='ListView' ,Mandatory=$true,Position=1,ValueFromPipelineByPropertyName=$true)]
    [String[]]$Property,

    # If set, will rename the properties in the table.
    # The oldname is the name of the old property, and value is either the new header
    [Parameter(ParameterSetName='TableView', Position=2,ValueFromPipelineByPropertyName=$true)]
    [Parameter(ParameterSetName='ListView', Position=2,ValueFromPipelineByPropertyName=$true)]
    [Alias('RenamedProperty', 'RenameProperty')]
    [ValidateScript({
        foreach ($kv in $_.GetEnumerator()) {
            if ($kv.Key -isnot [string] -or $kv.Value -isnot [string]) {
                throw "All keys and values in the property rename map must be strings"
            }
        }
        return $true
    })]
    [Hashtable]$AliasProperty,

    # If set, will create a number of virtual properties within a table
    [Parameter(ParameterSetName='TableView', Position=3,ValueFromPipelineByPropertyName=$true)]
    [Parameter(ParameterSetName='ListView', Position=3,ValueFromPipelineByPropertyName=$true)]
    [ValidateScript({
        foreach ($kv in $_.GetEnumerator()) {
            if ($kv.Key -isnot [string] -or $kv.Value -isnot [ScriptBlock]) {
                throw "The virtual property may only contain property names and the script blocks that will produce the property"
            }
        }
        return $true
    })]
    [Hashtable]$VirtualProperty,

    # If set, will be used to format the value of a property.
    [Parameter(ParameterSetName='TableView', Position=4,ValueFromPipelineByPropertyName=$true)]
    [Parameter(ParameterSetName='ListView', Position=4,ValueFromPipelineByPropertyName=$true)]
    [ValidateScript({
        foreach ($kv in $_.GetEnumerator()) {
            if ($kv.Key -isnot [string] -or $kv.Value -isnot [string]) {
                throw "The FormatProperty parameter must contain only strings"
            }
        }
        return $true
    })]
    [Hashtable]$FormatProperty,

    # If provided, will set the alignment used to display a given property.
    [Parameter(ValueFromPipelineByPropertyName=$true,ParameterSetName='TableView')]
    [ValidateScript({
        foreach ($kv in $_.GetEnumerator()) {
            if ($kv.Key -isnot [string] -or 'left', 'right', 'center' -notcontains $kv.Value) {
                throw 'The alignment property may only contain property names and the values: left, right, and center'
            }
        }
        return $true
    })]
    [Collections.IDictionary]$AlignProperty,

    # If provided, will conditionally color the property.
    # This will add colorization in the hosts that support it, and act normally in hosts that do not.
    # The key is the name of the property.  The value is a script block that may return one or two colors as strings.
    # The color strings may be ANSI escape codes or two hexadecimal colors (the foreground color and the background color)
    [Parameter(ValueFromPipelineByPropertyName=$true,ParameterSetName='TableView')]
    [Parameter(ValueFromPipelineByPropertyName=$true,ParameterSetName='ListView')]
    [ValidateScript({
        foreach ($kv in $_.GetEnumerator()) {
            if ($kv.Key -isnot [string] -or $kv.Value -isnot [ScriptBlock]) {
                throw "May only contain property names and script blocks"
            }
        }
        return $true
    })]
    [Alias('ColourProperty')]
    [Collections.IDictionary]$ColorProperty,

    # If provided, will colorize all rows in a table, according to the script block.
    # If the script block returns a value, it will be treated either as an ANSI escape sequence or up to two hexadecimal colors
    [Parameter(ParameterSetName='TableView')]
    [Alias('ColourRow')]
    [ValidateScript({
        $validTypeList = [System.String],[System.Management.Automation.ScriptBlock]
        $thisType = $_.GetType()
        $IsTypeOk =
            $(@( foreach ($validType in $validTypeList) {
                if ($_ -as $validType) {
                    $true;break
                }
            }))
        if (-not $isTypeOk) {
            throw "Unexpected type '$(@($thisType)[0])'.  Must be 'string','scriptblock'."
        }
        return $true
    })]
    [psobject]$ColorRow,

    # If provided, will use $psStyle to style the property.
    # # This will add colorization in the hosts that support it, and act normally in hosts that do not.
    # The key is the name of the property.  The value is a script block that may return one or more $psStyle property names.
    [Parameter(ValueFromPipelineByPropertyName,ParameterSetName='TableView')]
    [Parameter(ValueFromPipelineByPropertyName,ParameterSetName='ListView')]
    [Collections.IDictionary]$StyleProperty,
    

    # If provided, will style all rows in a table, according to the script block.
    # If the script block returns a value, it will be treated as a value on $PSStyle.
    [ValidateScript({
        $validTypeList = [System.String],[System.Management.Automation.ScriptBlock]
        $thisType = $_.GetType()
        $IsTypeOk =
            $(@( foreach ($validType in $validTypeList) {
                if ($_ -as $validType) {
                    $true;break
                }
            }))
        if (-not $isTypeOk) {
            throw "Unexpected type '$(@($thisType)[0])'.  Must be 'string','scriptblock'."
        }
        return $true
    })]
    [psobject]$StyleRow,


    # If set, then the content will be rendered as a list
    [Parameter(Mandatory=$true,ParameterSetName='ListView' ,ValueFromPipelineByPropertyName=$true)]
    [Switch]$AsList,

    # If set, the table will be autosized.
    [Parameter(ParameterSetName='TableView')]
    [Parameter(ParameterSetName='WideView')]
    [Switch]
    $AutoSize,

    # If set, the table headers will not be displayed.
    [Parameter(ParameterSetName='TableView')]
    [Alias('HideTableHeaders')]
    [switch]
    $HideHeader,

    # The width of any the properties.  This parameter is optional, and cannot be used with
    # AutoSize
    # A negative width is a right justified table.
    # A positive width is a left justified table
    # A width of 0 will be ignored.
    [ValidateRange(-80,80)]
    [Parameter(ParameterSetName='TableView',ValueFromPipelineByPropertyName=$true)]
    [Int[]]$Width,

    # If provided, will only display a list property if the condition is met.
    [Parameter(ValueFromPipelineByPropertyName=$true,ParameterSetName='ListView')]
    [ValidateScript({
        foreach ($kv in $_.GetEnumerator()) {
            if ($kv.Key -isnot [string] -or $kv.Value -isnot [ScriptBlock]) {
                throw "May only contain property names and script blocks"
            }
        }
        return $true
    })]
    [Collections.IDictionary]$ConditionalProperty,


    # The script block used to fill in the contents of a custom control.
    # The script block can either be an arbitrary script, which will be run, or it can include a
    # number of speicalized commands that will translate into parts of the formatter.
    [Parameter(Mandatory=$true,ParameterSetName='Action',ValueFromPipelineByPropertyName=$true)]
    [ScriptBlock[]]
    $Action,

    # The indentation depth of the custom control
    [Parameter(ParameterSetName='Action',ValueFromPipelineByPropertyName=$true)]
    [int]
    $Indent,

    # Passes thru the provided Format XML.
    # This can be used to include PowerShell formatter features not yet supported by EZOut.
    [Parameter(Mandatory=$true,ParameterSetName='FormatXML',ValueFromPipelineByPropertyName=$true)]
    [xml]
    $FormatXML,

    # If set, it will treat the type name as a selection set (a set of predefined types)
    [Switch]$IsSelectionSet,

    # If wrap is set, then items in the table can span multiple lines
    [Parameter(ParameterSetName='TableView')]
    [Switch]$Wrap,

    # If this is set, then the view will be grouped by a property.
    [String]$GroupByProperty,

    # If this is set, then the view will be grouped by the result of a script block
    [ScriptBlock]$GroupByScript,

    # If this is set, then the view will be labeled with the value of this parameter.
    [String]$GroupLabel,

    # If this is set, then the view will be rendered with a custom action.  The custom action can
    # be defined by using the -AsControl parameter in Write-FormatView.  The action does not have
    # to be defined within the same format file.
    [string]$GroupAction,

    # If set, will output the format view as an action (a view that can be reused again and again)
    [Parameter(ParameterSetName='Action',ValueFromPipelineByPropertyName=$true)]
    [Switch]$AsControl,

    # If the format view is going to be outputted as a control, it will require a name
    [Parameter(ValueFromPipelineByPropertyName=$true)]
    [String]$Name)

    process {
        #region Generate Format Content
        [string]$FormatContent = ""
        $parameterCopy = [Ordered]@{} + $psBoundParameters
        if ($psCmdlet.ParameterSetName -eq "Action") {
            $FormatContent = $parameterCopy | &amp; ${.@} Write-FormatCustomView
        } elseif ($psCmdlet.ParameterSetName -eq 'TableView') {
            $formatContent = $parameterCopy | &amp; ${.@} Write-FormatTableView
        } elseif ($psCmdlet.ParameterSetName -eq "ListView") {
            $formatContent = $parameterCopy | &amp; ${.@} Write-FormatListView
        }
        #endregion Generate Format Content

        if (-not $IsSelectionSet) {
            $typeNameElements = foreach ($t in $typeName) {
                "&lt;TypeName&gt;$T&lt;/TypeName&gt;"
            }
        } else {
            $typeNameElements = foreach ($t in $typeName) {
                "&lt;SelectionSetName&gt;$T&lt;/SelectionSetName&gt;"
            }

        }


        if ($psCmdlet.ParameterSetName -eq 'FormatXML') {
            $xOut = [IO.StringWriter]::new()
            $FormatXML.Save($xOut)
            $FormatContent = "$xOut".Substring('&lt;?xml version="1.0" encoding="utf-16"?&gt;'.Length + [Environment]::Newline.Length)
            if ($FormatXML.FirstChild.LocalName -notlike '*Control') {
                return $FormatContent
            }
        }

        if ($AsControl) {
            $xml = [xml]$formatContent
        } else {
            $ofs = ""
            $groupBy = ""
            $groupByPropertyOrScript = ""
            if ($GroupByProperty -or $GroupByScript) {
                if ($GroupByProperty) {
                    $groupByPropertyOrScript = "&lt;PropertyName&gt;$GroupByProperty&lt;/PropertyName&gt;"
                } else {
                    $groupByPropertyOrScript = "&lt;ScriptBlock&gt;$groupByScript&lt;/ScriptBlock&gt;"
                }
                if ($GroupLabel) {
                    $GroupByLabelOrControl = "&lt;Label&gt;$GroupLabel&lt;/Label&gt;"
                } elseif ($GroupAction) {
                    $GroupByLabelOrControl = "&lt;CustomControlName&gt;$GroupAction&lt;/CustomControlName&gt;"
                }

                $groupBy  = "&lt;GroupBy&gt;
            $GroupByPropertyOrScript
            $GroupByLabelOrControl
    &lt;/GroupBy&gt;"
            }
    $viewName = $Name
    if (-not $viewName)  {
        $viewName = $typeName[0]
    }
    $xml = [xml]"
    &lt;View&gt;
        &lt;Name&gt;$viewName&lt;/Name&gt;
        &lt;ViewSelectedBy&gt;
            $typeNameElements
        &lt;/ViewSelectedBy&gt;
        $GroupBy
        $FormatContent
    &lt;/View&gt;
    "
        }

        $strWrite = [IO.StringWriter]::new()
        $xml.Save($strWrite)
        return "$strWrite"
    }


                    </Script>
      </ScriptMethod>
      <ScriptMethod>
        <Name>Write-FormatViewExpression</Name>
        <Script>
                        
    &lt;#
    .Synopsis
        Writes a Format XML View Expression
    .Description
        Writes an expression for a Format .PS1XML.
        Expressions are used by custom format views and controls to conditionally display content.
    .Example
        Write-FormatViewExpression -ScriptBlock {
            "hello world"
        }
    .Example
        Write-FormatViewExpression -If { $_.Complete } -ScriptBlock { "Complete" }
    .Example
        Write-FormatViewExpression -Text 'Hello World'
    .Example
        # This will render the property 'Name' property of the underlying object
        Write-FormatViewExpression -Property Name
    .Example
        # This will render the property 'Status' of the current object,
        # if the current object's 'Complete' property is $false.
        Write-FormatViewExpression -Property Status -If { -not $_.Complete }    
    #&gt;
    [CmdletBinding(DefaultParameterSetName='ScriptBlock')]
    [OutputType([string])]
    [Alias('Show-CustomAction')]
    param(
    # The name of the control.  If this is provided, it will be used to display the property or script block.
    [Parameter(ValueFromPipelineByPropertyName)]
    [Alias('ActionName','Name')]
    [String]
    $ControlName,

    # If a property name is provided, then the custom action will show the contents
    # of the property
    [Parameter(Mandatory=$true,ParameterSetName='Property',Position=0,ValueFromPipelineByPropertyName)]
    [Alias('PropertyName')]
    [String]
    $Property,

    # If a script block is provided, then the custom action shown in formatting
    # will be the result of the script block.
    [Parameter(Mandatory=$true,ParameterSetName='ScriptBlock',Position=0,ValueFromPipelineByPropertyName)]
    [ScriptBlock]
    $ScriptBlock,

    # If provided, will make the expression conditional.  -If it returns a value, the script block will run
    [Parameter(ValueFromPipelineByPropertyName=$true)]
    [Alias('ItemSelectionCondition')]
    [ScriptBlock]
    $If,

    # If provided, will output the provided text.  All other parameters are ignored.
    [Parameter(Mandatory,ParameterSetName='Text',ValueFromPipelineByPropertyName)]
    [string]
    $Text,

    # If -AssemblyName, -BaseName, and -ResourceID are provided, localized text resources will be outputted.
    [Parameter(Mandatory,ParameterSetName='LocalizedText',ValueFromPipelineByPropertyName)]
    [string]
    $AssemblyName,

    # If -AssemblyName, -BaseName, and -ResourceID are provided, localized text resources will be outputted.
    [Parameter(Mandatory,ParameterSetName='LocalizedText',ValueFromPipelineByPropertyName)]
    [string]
    $BaseName,

    # If -AssemblyName, -BaseName, and -ResourceID are provided, localized text resources will be outputted.
    [Parameter(Mandatory,ParameterSetName='LocalizedText',ValueFromPipelineByPropertyName)]
    [string]
    $ResourceID,

    # If provided, will output a &lt;NewLine /&gt; element.  All other parameters are ignored.
    [Parameter(Mandatory=$true,ParameterSetName='NewLine',ValueFromPipelineByPropertyName)]
    [switch]
    $Newline,

    # If set, will put the expression within a &lt;Frame&gt; element.
    [Parameter(ValueFromPipelineByPropertyName)]
    [switch]
    $Frame,

    # If provided, will indent by a number of characters.  This implies -Frame.
    [Parameter(ValueFromPipelineByPropertyName)]
    [Alias('Indent')]
    [ValidateRange(0,1mb)]
    [int]
    $LeftIndent,

    # If provided, will indent the right by a number of characters.  This implies -Frame.
    [Parameter(ValueFromPipelineByPropertyName)]
    [ValidateRange(0,1mb)]
    [int]
    $RightIndent,

    # Specifies how many characters the first line of data is shifted to the left.  This implies -Frame.
    [Parameter(ValueFromPipelineByPropertyName)]
    [ValidateRange(0,1mb)]
    [int]
    $FirstLineHanging,

    # Specifies how many characters the first line of data is shifted to the right.  This implies -Frame.
    [Parameter(ValueFromPipelineByPropertyName)]
    [ValidateRange(0,1mb)]
    [int]
    $FirstLineIndent,

    # The name of one or more $psStyle properties to apply.
    # If $psStyle is present, this will use put these properties prior to an expression.
    # A $psStyle.Reset will be outputted after the expression.
    [Alias('PSStyle', 'PSStyles')]
    [string[]]
    $Style,

    # If set, will bold the -Text, -Property, or -ScriptBlock.
    # This is only valid in consoles that support ANSI terminals ($host.UI.SupportsVirtualTerminal),
    # or while rendering HTML
    [switch]
    $Bold,

    # If set, will underline the -Text, -Property, or -ScriptBlock.
    # This is only valid in consoles that support ANSI terminals, or in HTML
    [switch]
    $Underline,

    # If set, will double underline the -Text, -Property, or -ScriptBlock.
    # This is only valid in consoles that support ANSI terminals, or in HTML
    [switch]
    $DoubleUnderline,

    # If set, make the -Text, -Property, or -ScriptBlock Italic.
    # This is only valid in consoles that support ANSI terminals, or in HTML
    [Alias('Italics')]
    [switch]
    $Italic,

    # If set, will hide  the -Text, -Property, or -ScriptBlock.
    # This is only valid in consoles that support ANSI terminals, or in HTML
    [switch]
    $Hide,

    # If set, will invert the -Text, -Property, -or -ScriptBlock
    # This is only valid in consoles that support ANSI terminals, or in HTML.
    [switch]
    $Invert,

    # If set, will cross out the -Text, -Property, -or -ScriptBlock
    # This is only valid in consoles that support ANSI terminals, or in HTML.
    [Alias('Strikethrough', 'Crossout')]
    [switch]$Strikethru,

    # If provided, will output the format using this format string.
    [string]
    $FormatString,

    # If this is set, collections will be enumerated.
    [Parameter(ValueFromPipelineByPropertyName=$true)]
    [Alias('EnumerateCollection')]
    [Switch]
    $Enumerate,

    # If provided, will display the content using the given foreground color.
    # This will only be displayed on hosts that support rich color.
    # Colors can be:
    # * An RGB color
    # * The name of a color stored in a .Colors section of a .PrivateData in a manifest
    # * The name of a Standard Concole Color
    # * The name of a PowerShell stream, e.g. Output, Warning, Debug, etc 
    [Alias('FG', 'ForegroundColour')]
    [string]
    $ForegroundColor,

    # If provided, will display the content using the given background color.
    # This will only be displayed on hosts that support rich color.
    # Colors can be:
    # * An RGB color
    # * The name of a color stored in a .Colors section of a .PrivateData in a manifest
    # * The name of a Standard Concole Color
    # * The name of a PowerShell stream, e.g. Output, Warning, Debug, etc
    [Alias('BG', 'BackgroundColour')]
    [string]
    $BackgroundColor,

    # The number of times the item will be displayed.
    # With script blocks, the variables $N and $Number will be set to indicate the current iteration.
    [ValidateRange(1,10kb)]
    [uint32]
    $Count = 1
    )

    process {
        # If this is calling itself recursively in ScriptBlock
        if ($ScriptBlock -and $ScriptBlock -like "*$($MyInvocation.MyCommand.Name)*") {
            &amp; $ScriptBlock # run the script and return.
            return
        }

        if ($Newline) {
            foreach ($n in 1..$Count) {
                "&lt;NewLine/&gt;"
            }
            return
        }

        foreach ($n in 1..$count) {
            if ($Style) {
                $scriptLines = @(
'if ($psStyle) {'
"   @(foreach (`$styleProp in '$($style -join "','")') {"
{
        if ($styleProp -match '^\$') {
            $ExecutionContext.SessionState.InvokeCommand.InvokeScript($styleProp)
        }
        elseif ($styleProp -match '\.') {
            $targetObject = $psStyle
            foreach ($dotProperty in $styleProp -split '(?&lt;!\.)\.') {
                if (
                    ($targetObject.psobject.Members['Item'] -and 
                        ($targetObject.Item -is [Management.Automation.PSMethodInfo])
                    ) -or 
                    $targetObject -is [Collections.IDictionary]
                ) {
                    $targetObject = $targetObject[$dotProperty]
                } else {
                    $targetObject = $targetObject.$dotProperty
                }
            }
            if ($targetObject) {
                $targetObject
            }
        }
        else {
            $psStyle.$styleProp
        }    
}
"   }) -ne '' -join ''"
'}'
                )
                $styleScript = [ScriptBlock]::Create($scriptLines -join [Environment]::NewLine)
                Write-FormatViewExpression -ScriptBlock $styleScript -If $if
            }
            if ($ForegroundColor -or 
                $BackgroundColor -or 
                $Bold -or 
                $Underline -or 
                $Italic -or 
                $Faint -or 
                $doubleUnderline -or 
                $Invert -or
                $Strikethru -or
                $hide) {                
                $colorize = [ScriptBlock]::Create("@(Format-RichText $(@(
                    if ($ForegroundColor) {
                        "-ForegroundColor '$ForeGroundColor'"
                    }
                    if ($BackgroundColor) {
                        "-BackgroundColor '$BackgroundColor'"
                    }
                    if ($Italic) { '-Italic' }
                    if ($Bold) { '-Bold' }
                    if ($Faint) { '-Faint' }
                    if ($Underline) { '-Underline'}
                    if ($DoubleUnderline) { '-DoubleUnderline'}
                    if ($hide) { '-Hide' }
                    if ($Invert) { '-Invert' }
                    if ($Strikethru) { '-Strikethru' }
                    '-NoClear'
                ) -join ' ')) -join ''")
                Write-FormatViewExpression -ScriptBlock $colorize -If $if
            }

            $ControlChunk = if ($ControlName) { "&lt;CustomControlName&gt;$([Security.SecurityElement]::Escape($ControlName))&lt;/CustomControlName&gt;" }
            $EnumerationChunk = if ($Enumerate) { '&lt;EnumerateCollection/&gt;' } else { '' }
            $formatChunk = if ($FormatString) { "&lt;FormatString&gt;$([Security.SecurityElement]::Escape($FormatString))&lt;/FormatString&gt;"}

            if ($Text) {
                "&lt;Text&gt;$([Security.SecurityElement]::Escape($Text))&lt;/Text&gt;"
            } 
            elseif ($AssemblyName -and $BaseName -and $ResourceID) {
                "&lt;Text AssemblyName='$AssemblyName' BaseName='$BaseName' ResourceId='$ResourceID' /&gt;"
            }
            else {
                if ($Count -gt 1 -and $PSBoundParameters.ContainsKey('ScriptBlock')) {
                    $ScriptBlock = [ScriptBlock]::Create("`$n = `$number = $n;
$($PSBoundParameters['ScriptBlock'])
")
                }

    $formatExpression = @"
&lt;ExpressionBinding&gt;
    $(if ($If) {
        if ($count -gt 1) {
            $if = [ScriptBlock]::Create("`$n = `$number = $n;
$if")
        }
        "&lt;ItemSelectionCondition&gt;&lt;ScriptBlock&gt;$([Security.SecurityElement]::Escape($if))&lt;/ScriptBlock&gt;&lt;/ItemSelectionCondition&gt;"
    })
    $(if ($Property) { "&lt;PropertyName&gt;$([Security.SecurityElement]::Escape($Property))&lt;/PropertyName&gt;" })
    $(if ($ScriptBlock) { "&lt;ScriptBlock&gt;$([Security.SecurityElement]::Escape($ScriptBlock))&lt;/ScriptBlock&gt;"})
    $EnumerationChunk
    $formatChunk
    $ControlChunk
&lt;/ExpressionBinding&gt;
"@

if ($Frame -or $FirstLineHanging -or $LeftIndent -or $RightIndent -or $FirstLineIndent) {
    $formatExpression = "
&lt;Frame&gt;
    $(
        if ($LeftIndent) { "&lt;LeftIndent&gt;$LeftIndent&lt;/LeftIndent&gt;" }
        if ($RightIndent) { "&lt;RightIndent&gt;$RightIndent&lt;/RightIndent&gt;" }
        if ($FirstLineHanging) { "&lt;FirstLineHanging&gt;$FirstLineHanging&lt;/FirstLineHanging&gt;" }
        if ($FirstLineIndent) { "&lt;FirstLineIndent&gt;$FirstLineIndent&lt;/FirstLineIndent&gt;" }
    )
    &lt;CustomItem&gt;
        $FormatExpression
    &lt;/CustomItem&gt;
&lt;/Frame&gt;
"
}
                $xml = [xml]$formatExpression
                if (-not $xml) { return }
                $xOut=[IO.StringWriter]::new()
                $xml.Save($xOut)
                "$xOut".Substring('&lt;?xml version="1.0" encoding="utf-16"?&gt;'.Length + [Environment]::NewLine.Length)
                $xOut.Dispose()
            }
            if ($style) {
                Write-FormatViewExpression -ScriptBlock {
                    if ($PSStyle) {
                        $PSStyle.Reset
                    }
                } -If $if
            }
            elseif ($ForegroundColor -or 
                $BackgroundColor -or 
                $Bold -or 
                $Underline -or 
                $Italic -or 
                $Faint -or 
                $doubleUnderline -or 
                $Invert -or
                $Hide -or 
                $Strikethru
            ) {
                Write-FormatViewExpression -ScriptBlock ([ScriptBlock]::Create(($colorize -replace '-NoClear'))) -If $if
            }
        }
    }

                    </Script>
      </ScriptMethod>
      <ScriptMethod>
        <Name>Write-FormatWideView</Name>
        <Script>
                        
    [CmdletBinding(DefaultParameterSetName='Property')]
    param(
    # The name of the property displayed in the wide view.
    [Parameter(Mandatory=$true,ParameterSetName='OfProperty',ValueFromPipelineByPropertyName=$true)]
    [string]$Property,

    # The script block displayed in the wide view.
    [Parameter(Mandatory=$true,ParameterSetName='OfScriptBlock',ValueFromPipelineByPropertyName=$true)]
    [ScriptBlock]$ScriptBlock,

    # The view type name.  This allows for a view to be displayed selectively, based off of a typename.
    [Parameter(ValueFromPipelineByPropertyName=$true)]
    [string]
    $ViewTypeName,

    # The view condition.  This allows for a view to be displayed selectively, based off of a condition.
    # This must be used with -ViewTypeName or -ViewSelectionSet.
    [Parameter(ValueFromPipelineByPropertyName=$true)]
    [ScriptBlock]
    $ViewCondition,

    # The View Selection Set.  This allows for a view to be displayed selectively, based of a selection set name.
    [Parameter(ValueFromPipelineByPropertyName=$true)]
    [string]
    $ViewSelectionSet,

    # If set, the view will be automatically sized.
    # This cannot be ignored if a ColumnCount is provided.
    [switch]
    $AutoSize,

    # The number of columns that will be displayed.
    # This will take override -AutoSize
    [Alias('Columns','ColumnNumber')]
    [int]
    $ColumnCount)

    begin {
        $accumulated = [Collections.ArrayList]::new()
    }
    process {
        $null = $accumulated.Add(@{} + $PSBoundParameters)
    }

    end {
        $xml = &amp; {
        '&lt;WideControl&gt;'
        if ($ColumnCount) {
            "&lt;ColumnNumber&gt;$ColumnCount&lt;/ColumnNumber&gt;"
        } elseif ($AutoSize) {
            '&lt;AutoSize/&gt;'
        }
        '&lt;WideEntries&gt;'
        foreach ($item in $accumulated) {
            '&lt;WideEntry&gt;'
            if ($item.ViewTypeName -or $item.ViewSelectionSet) {
                "&lt;EntrySelectedBy&gt;"
                if ($item.ViewCondition) {
                    "&lt;SelectionCondition&gt;"
                }
                foreach ($tn in $item.ViewTypeName) {
                    "&lt;TypeName&gt;$([Security.SecurityElement]::Escape($tn))&lt;/TypeName&gt;"
                }
                foreach ($ssn in $item.ViewSelectionSet) {
                    "&lt;SelectionSetName&gt;$([Security.SecurityElement]::Escape($ssn))&lt;/SelectionSetName&gt;"
                }
                if ($item.ViewCondition) {
                    "&lt;ScriptBlock&gt;$([Security.SecurityElement]::Escape($item.ViewCondition))&lt;/ScriptBlock&gt;"
                    "&lt;/SelectionCondition&gt;"
                }
                "&lt;/EntrySelectedBy&gt;"
            }
            '&lt;WideItem&gt;'
            if ($item.Property) {
                '&lt;PropertyName&gt;'
                [Security.SecurityElement]::Escape($item.Property)
                '&lt;/PropertyName&gt;'
            } elseif ($item.ScriptBlock) {
                '&lt;ScriptBlock&gt;'
                [Security.SecurityElement]::Escape($item.ScriptBlock)
                '&lt;/ScriptBlock&gt;'
            }
            '&lt;/WideItem&gt;'
            '&lt;/WideEntry&gt;'
        }
        '&lt;/WideEntries&gt;'
        '&lt;/WideControl&gt;'
        }

        $xml = [xml]($xml -join '')

        if (-not $xml) { return }
        $xOut=[IO.StringWriter]::new()
        $xml.Save($xOut)
        "$xOut".Substring('&lt;?xml version="1.0" encoding="utf-16"?&gt;'.Length + [Environment]::NewLine.Length)
    }

                    </Script>
      </ScriptMethod>
      <ScriptMethod>
        <Name>Write-PropertySet</Name>
        <Script>
                        
    &lt;#
    .Synopsis
        Writes a property set
    .Description
        Writes a property set.

        Property sets are a way to conveniently access sets of properties on an object.

        Instead of writing:

            Select-Object a,b,c,d

        You can write:

            Select-Object mypropertyset
    .Example
        Write-PropertySet -typename System.IO.FileInfo -name filetimes -propertyname Name, LastAccessTime, CreationTime, LastWriteTime |
            Out-TypeData |
            Add-TypeData

        dir | select filetimes
    .Link
        ConvertTo-PropertySet
    .Link
        Get-PropertySet
    .Link
        Out-TypeData
    .Link
        Add-TypeData
    #&gt;
    param(
    # The typename for the property set
    [Parameter(Mandatory=$true,ValueFromPipelineByPropertyName=$true)]
    [string]
    $TypeName,

    # The name of the property set
    [Parameter(Mandatory=$true,ValueFromPipelineByPropertyName=$true)]
    [string]
    $Name,

    # The names of the properties to include in the property set
    [Parameter(Mandatory=$true,ValueFromPipelineByPropertyName=$true)]
    [string[]]
    $PropertyName
    )
    begin {
        [Hashtable]$PropertySet = @{}
    }
    process {
        $PropertySet.$name = $PropertyName
    }
    end {
        Write-TypeView -TypeName $TypeName -PropertySet $PropertySet
    }

                    </Script>
      </ScriptMethod>
      <ScriptMethod>
        <Name>Write-TypeView</Name>
        <Script>
                        
    &lt;#
    .Synopsis
        Writes extended type view information
    .Description
        PowerShell has a robust, extensible types system.  With Write-TypeView, you can easily add extended type information to any type.
        This can include:
            The default set of properties to display (-DefaultDisplay)
            Sets of properties to display (-PropertySet)
            Serialization Depth (-SerializationDepth)
            Virtual methods or properties to add onto the type (-ScriptMethod, -ScriptProperty and -NoteProperty)
            Method or property aliasing (-AliasProperty)
    .Link
        Out-TypeView
    .Link
        Add-TypeView
    #&gt;
    [OutputType([string])]
    param(
    # The name of the type.
    # Multiple type names will all have the same methods, properties, events, etc.
    [Parameter(Mandatory,ValueFromPipelineByPropertyName,Position=0)]
    [String[]]
    $TypeName,

    # A collection of virtual method names and the script blocks that will be used to run the virtual method.
    [ValidateScript({
        if ($_.Keys | Where-Object {$_-isnot [string]}) {
            throw "Must provide the names of script methods"
        }
        if ($_.Values | Where-Object {$_ -isnot [ScriptBlock]}) {
            throw "Must provide script blocks to handle each method"
        }
        return $true
    })]
    [Collections.IDictionary]$ScriptMethod = @{},

    # A Collection of virtual property names and the script blocks that will be used to get the property values.
    [ValidateScript({
        $in = $_
        foreach ($kv in $in.GetEnumerator()) {
            if ($kv.Key -isnot [string]) {
                throw "Must provide the names of script properties"
            }
            if ($kv.Value.Count -gt 2) {
                throw "No more than two scripts can be provided"
            }
            foreach ($_ in $kv.Value) {
                if ($_ -isnot [ScriptBlock]) {
                    throw "Must provide script blocks to handle each property"
                }
            }
        }
        return $true
    })]
    [Collections.IDictionary]$ScriptProperty,

    # A collection of fixed property values.
    [ValidateScript({
        if ($_.Keys | Where-Object { $_-isnot [string] } ) {
            throw "Must provide the names of note properties"
        }
        return $true
    })]
    [Collections.IDictionary]$NoteProperty,

    # A collection of property aliases
    [ValidateScript({
        foreach ($kv in $_.GetEnumerator()) {
            if ($kv.Key -isnot [string] -or $kv.Value -isnot [string]) {
                throw "All keys and values in the property rename map must be strings"
            }
        }
        return $true
    })]
    [Collections.IDictionary]$AliasProperty,

    # A collection of scripts that may create events.
    # These will become ScriptMethods.
    # * Send_NameOfEvent will call the generator and optionally send an event.  Arguments will may be passed along to the event.
    # * Register_NameOfEvent({}) will call Register-EngineEvent to register an event handler
    # * Unregister_NameOfEvent([[PSEventSubscriber]) will call Unregister-EngineEvent to remove the handler.
    [ValidateScript({
        if ($_.Keys | Where-Object {$_-isnot [string]}) {
            throw "Must provide the names of events methods"
        }
        if ($_.Values | Where-Object {$_ -isnot [ScriptBlock] -and $_ -notlike '*New-Event*'}) {
            throw "Must provide script blocks for values, and each must contain New-Event"
        }
        return $true
    })]
    [Collections.IDictionary]$EventGenerator,

    # A list of event names.
    # These will become ScriptMethods.
    # * Send_NameOfEvent will call the generator and optionally send an event.  Arguments will be sent as event and message data.
    # * Register_NameOfEvent({}) will call Register-EngineEvent to register an event handler
    # * Unregister_NameOfEvent([[PSEventSubscriber]) will call Unregister-EngineEvent to remove the handler.
    [string[]]$EventName,

    # The default display.
    # This is the default set of properties to display if no formatter is specified.    
    [string[]]$DefaultDisplay,

    # The default key property set.
    # This is the set of properties that will be used as the key for the object.
    [string[]]$DefaultKey,

    # The ID property
    [string]$IdProperty,

    &lt;#
    
    The serialization depth.

    Serialization depth can be used to minimize the overhead of objects.
    
    If the type is deserialized, this is the depth of subpropeties that will be stored.
    
    For instance, a serialization depth of 3 would store:
      * an object, 
      * it's subproperties
      * those objects' subproperties
      
    The default serialization depth is 2.
    #&gt;    
    [int]$SerializationDepth = 2,

    # The reserializer type used for recreating a deserialized type.
    # If none is provided, consider using -Deserialized
    [Type]$Reserializer,

    # Property sets define default views for an object.  A property set can be used with Select-Object
    # to display just that set of properties.
    [ValidateScript({
        if ($_.Keys | Where-Object {$_ -isnot [string] } ) {
            throw "Must provide the names of property sets"
        }
        if ($_.Values |
            Where-Object {$_ -isnot [string] -and  $_ -isnot [Object[]] -and $_ -isnot [string[]] }){
            throw "Must provide a name or list of names for each property set"
        }
        return $true
    })]
    [Collections.IDictionary]$PropertySet,

    # If provided, will hide any properties in the list from automatically being displayed.
    [string[]]$HideProperty,

    # If set, will generate an identical typeview for the deserialized form of each typename.
    [switch]$Deserialized
    )

    begin {        
        $RegisterMethod = {
            param(
            [Parameter(Mandatory)]
            [string]
            $SourceIdentifier
            )
            [ScriptBlock]::Create(@"
param([ScriptBlock]`$EventHandler, `$SourceIdentifier = '$SourceIdentifier')
Register-EngineEvent -SourceIdentifier `$SourceIdentifier -Action `$EventHandler
"@)
        }

        $UnregisterMethod =
            [ScriptBlock]::Create(@"
param(`$EventHandler)
if (`$Eventhandler -is [Management.Automation.PSEventSubscriber]) {
    `$Eventhandler | Unregister-Event
} elseif (`$eventHandler -is [string]) {
    Get-EventSubscriber -SourceIdentifier `$EventHandler -ErrorAction SilentlyContinue  | Unregister-Event
}  elseif (`$eventHandler -is [int]) {
    Get-EventSubscriber -SubscriptionID `$EventHandler -ErrorAction SilentlyContinue | Unregister-Event
} elseif (`$eventHandler -is [ScriptBlock]) {
    Get-EventSubscriber |
        Where-Object { (`$_.Action.Command -replace '\s') -eq (`$eventHandler -replace '\s')} | Unregister-Event
} else {
    throw "Handler must be a [PSEventSubscriber], [ScriptBlock], a [string] SourceIdentifier, or an [int]SubscriptionID"
}
"@)

        $DebugBuild = 
            $DebugPreference -ne 'SilentlyContinue' -and $DebugPreference -ne 'Ignore'
    }

    process {
        if ($Deserialized -and $TypeName -notlike 'Deserialized.*') {
            $typeName =
                foreach ($tn in $TypeName) {
                    if (-not ("&lt;TypeName&gt;$tn&lt;/TypeName&gt;" -as [xml])) {
                        $tn = [Security.SecurityElement]::Escape($tn)
                    }
                    $tn, "Deserialized.$tn"
                }
        }


        # Before we get started, we want to turn the abstract idea of Events into ScriptMethods
        if ($EventGenerator) { # Event Generators come first
            foreach ($evtGen in $EventGenerator.GetEnumerator()) {
                $evt = $evtGen.Key.Substring(0,1).ToUpper() + $evtGen.Key.Substring(1)
                $sendMethodName = "Send_$evt"
                $registerMethodName = "Register_$evt"
                $UnregisterMethodName = "Unregister_$evt"
                if ($ScriptMethod[$sendMethodName] -or     # If we already have Send_,
                    $ScriptMethod[$registerMethodName] -or # Register_,
                    $ScriptMethod[$unregisterMethodName]   # Unregister_
                ) {
                    # the user wants it that way.
                    continue
                }
                $ScriptMethod[$sendMethodName]     = $evtGen.Value
                $ScriptMethod[$registerMethodName] =
                    &amp; $RegisterMethod "$($TypeName -replace '^Deserialized\.').$($evtGen.Key)"
                $ScriptMethod[$UnregisterMethodName] =
                    &amp; $UnregisterMethod "$($TypeName -replace '^Deserialized\.').$($evtGen.Key)"
            }
        }
        elseif ($EventName) {
            foreach ($evtName in $EventName) {
                $evt = $evtName.Substring(0,1).ToUpper() + $evtName.Substring(1)
                $sendMethodName = "Send_$evt"
                $registerMethodName = "Register_$evt"
                $UnregisterMethodName = "Unregister_$evt"
                if ($ScriptMethod[$sendMethodName] -or     # If we already have Send_,
                    $ScriptMethod[$registerMethodName] -or # Register_,
                    $ScriptMethod[$unregisterMethodName]   # Unregister_
                ) {
                    # the user wants it that way.
                    continue
                }
                $evtSourceId = "$($TypeName -replace '^Deserialized\.').$evt"
                $ScriptMethod[$sendMethodName]     = [ScriptBlock]::Create("
                    New-Event -SourceIdentifier '$evtSourceId' -Sender `$this -EventArguments `$args -MessageData `$args
                ")
                $ScriptMethod[$registerMethodName] = &amp; $RegisterMethod $evtSourceId
                $ScriptMethod[$unregisterMethodName] = &amp; $unRegisterMethod $evtSourceId
            }
        }

        foreach ($tn in $TypeName) {
            $memberSetXml = ""
            if ($DebugBuild) {
                $updateSplat = [Ordered]@{
                    TypeName = $tn
                    Force = $true
                }
            }
            #region Construct PSStandardMembers
            if ($psBoundParameters.ContainsKey('SerializationDepth') -or
                $psBoundParameters.ContainsKey('IdProperty') -or
                $psBoundParameters.ContainsKey('DefaultDisplay') -or
                $psBoundParameters.ContainsKey('DefaultKey') -or
                $psBoundParameters.ContainsKey('Reserializer')) {
                $defaultDisplayXml = if ($psBoundParameters.ContainsKey('DefaultDisplay')) {
                    if ($DebugBuild) {
                        Update-TypeData @updateSplat -DefaultDisplayPropertySet $DefaultDisplay
                    }
    $referencedProperties = "&lt;Name&gt;" + ($defaultDisplay -join "&lt;/Name&gt;
                            &lt;Name&gt;") + "&lt;/Name&gt;"
    "                &lt;PropertySet&gt;
                        &lt;Name&gt;DefaultDisplayPropertySet&lt;/Name&gt;
                        &lt;ReferencedProperties&gt;
                            $referencedProperties
                        &lt;/ReferencedProperties&gt;
                    &lt;/PropertySet&gt;
    "
                }
                $defaultKeyXml = if ($psBoundParameters.ContainsKey('DefaultKey')) {
                    if ($DebugBuild) {
                        Update-TypeData @updateSplat -DefaultKeyPropertySet $DefaultKey
                    }
                    $referencedProperties = "&lt;Name&gt;" + ($DefaultKey -join "&lt;/Name&gt;
                            &lt;Name&gt;") + "&lt;/Name&gt;"
    "                &lt;PropertySet&gt;
                        &lt;Name&gt;DefaultKeyPropertySet&lt;/Name&gt;
                        &lt;ReferencedProperties&gt;
                            $referencedProperties
                        &lt;/ReferencedProperties&gt;
                    &lt;/PropertySet&gt;
    "
                }
                $serializationDepthXml = if ($psBoundParameters.ContainsKey('SerializationDepth')) {
                    if ($DebugBuild) {
                        Update-TypeData @updateSplat -SerializationDepth $SerializationDepth
                    }
                    "
                    &lt;NoteProperty&gt;
                        &lt;Name&gt;SerializationDepth&lt;/Name&gt;
                        &lt;Value&gt;$SerializationDepth&lt;/Value&gt;
                    &lt;/NoteProperty&gt;"
                } else {$null }

                $ReserializerXml = if ($psBoundParameters.ContainsKey('Reserializer'))  {
                    if ($DebugBuild) {
                        Update-TypeData @updateSplat -TargetTypeForDeserialization $Reserializer 
                    }
    "
                    &lt;NoteProperty&gt;
                        &lt;Name&gt;TargetTypeForDeserialization&lt;/Name&gt;
                        &lt;Value&gt;$($Reserializer.FullName)&lt;/Value&gt;
                    &lt;/NoteProperty&gt;

    "
                } else { $null }

                $memberSetXml = "
                &lt;MemberSet&gt;
                    &lt;Name&gt;PSStandardMembers&lt;/Name&gt;
                    &lt;Members&gt;
                        $(
                            @(
                                $defaultDisplayXml
                                $DefaultKeyXml
                                $serializationDepthXml
                                $reserializerXml
                            ) -ne $null -join [Environment]::NewLine
                        )
                    &lt;/Members&gt;
                &lt;/MemberSet&gt;
                "
            }
            #endregion Construct PSStandardMembers

            #region PropertySetXml
            $propertySetXml  = if ($psBoundParameters.PropertySet) {

                foreach ($NameAndValue in $PropertySet.GetEnumerator() | Sort-Object Key) {                    
                    $referencedProperties = "&lt;Name&gt;" + ($NameAndValue.Value -join "&lt;/Name&gt;
                        &lt;Name&gt;") + "&lt;/Name&gt;"
                "&lt;PropertySet&gt;
                    &lt;Name&gt;$([Security.SecurityElement]::Escape($NameAndValue.Key))&lt;/Name&gt;
                    &lt;ReferencedProperties&gt;
                        $referencedProperties
                    &lt;/ReferencedProperties&gt;
                &lt;/PropertySet&gt;"
                }
            } else {
                ""
            }
            #endregion



            #region Aliases
            $aliasPropertyXml = if ($psBoundParameters.AliasProperty) {
                foreach ($NameAndValue in $AliasProperty.GetEnumerator() | Sort-Object Key) {
                    $isHiddenChunk = if ($HideProperty -contains $NameAndValue.Key) {
                        'IsHidden="true"'
                    }
                    if ($DebugBuild) {                        
                        Update-TypeData @updateSplat -MemberType AliasProperty -MemberName $NameAndValue.Key -Value $NameAndValue.Value
                    }
                    "
                &lt;AliasProperty $isHiddenChunk&gt;
                    &lt;Name&gt;$([Security.SecurityElement]::Escape($NameAndValue.Key))&lt;/Name&gt;
                    &lt;ReferencedMemberName&gt;$([Security.SecurityElement]::Escape($NameAndValue.Value))&lt;/ReferencedMemberName&gt;
                &lt;/AliasProperty&gt;"
                }
            } else {
                ""
            }
            #endregion Aliases
            $NotePropertyXml = if ($psBoundParameters.NoteProperty) {
                foreach ($NameAndValue in $NoteProperty.GetEnumerator() | Sort-Object Key) {
                    if ($DebugBuild) {                        
                        Update-TypeData @updateSplat -MemberType NoteProperty -MemberName $NameAndValue.Key -Value $NameAndValue.Value
                    }
                    $isHiddenChunk = if ($HideProperty -contains $NameAndValue.Key) {
                        'IsHidden="true"'
                    }
                    "
                &lt;NoteProperty $isHiddenChunk&gt;
                    &lt;Name&gt;$([Security.SecurityElement]::Escape($NameAndValue.Key))&lt;/Name&gt;
                    &lt;Value&gt;$([Security.SecurityElement]::Escape($NameAndValue.Value))&lt;/Value&gt;
                &lt;/NoteProperty&gt;"
                }
            } else {
                ""
            }
            $scriptMethodXml = if ($ScriptMethod -and $ScriptMethod.Count) {                
                foreach ($methodNameAndCode in $ScriptMethod.GetEnumerator() | Sort-Object Key) {
                if ($DebugBuild) {                        
                    Update-TypeData @updateSplat -MemberType ScriptMethod -MemberName $methodNameAndCode.Key -Value $methodNameAndCode.Value
                }
                "&lt;ScriptMethod&gt;
                    &lt;Name&gt;$($methodNameAndCode.Key)&lt;/Name&gt;
                    &lt;Script&gt;
                        $([Security.SecurityElement]::Escape($methodNameAndCode.Value))
                    &lt;/Script&gt;
                &lt;/ScriptMethod&gt;"
                }
            } else {
                ""
            }

            #region Script Property
            $scriptPropertyXml = if ($psBoundParameters.ScriptProperty) {
                foreach ($propertyNameAndCode in $ScriptProperty.GetEnumerator() | Sort-Object Key) {
                    $isHiddenChunk = if ($HideProperty -contains $propertyNameAndCode.Key) {
                        'IsHidden="true"'
                    }
                    $getScript, $setScript = $propertyNameAndCode.Value
                    if ($getScript -and $setScript) {
                        if ($DebugBuild) {
                            Update-TypeData @updateSplat -MemberType ScriptProperty -MemberName $propertyNameAndCode.Key -Value $getScript -SecondValue $setScript
                        }

                        "
                &lt;ScriptProperty $isHiddenChunk&gt;
                    &lt;Name&gt;$($propertyNameAndCode.Key)&lt;/Name&gt;
                    &lt;GetScriptBlock&gt;
                        $([Security.SecurityElement]::Escape($getScript))
                    &lt;/GetScriptBlock&gt;
                    &lt;SetScriptBlock&gt;
                        $([Security.SecurityElement]::Escape($setScript))
                    &lt;/SetScriptBlock&gt;
                &lt;/ScriptProperty&gt;"
                    } else {
                        if ($DebugBuild) {
                            Update-TypeData @updateSplat -MemberType ScriptProperty -MemberName $propertyNameAndCode.Key -Value $getScript
                        }
                        "
                &lt;ScriptProperty $isHiddenChunk&gt;
                    &lt;Name&gt;$($propertyNameAndCode.Key)&lt;/Name&gt;
                    &lt;GetScriptBlock&gt;
                        $([Security.SecurityElement]::Escape($propertyNameAndCode.Value))
                    &lt;/GetScriptBlock&gt;
                &lt;/ScriptProperty&gt;"
                    }
                }
            }

            $innerXml = @($memberSetXml) + $propertySetXml + $aliasPropertyXml + $codePropertyXml + $codeMethodXml + $scriptMethodXml + $scriptPropertyXml + $NotePropertyXml

            $innerXml = ($innerXml  | Where-Object {$_} ) -join ([Environment]::NewLine)
            "
        &lt;Type&gt;
            &lt;Name&gt;$tn&lt;/Name&gt;
            &lt;Members&gt;
                $innerXml
            &lt;/Members&gt;
        &lt;/Type&gt;"
        }

        if ($DebugBuild) {
            $myModule = $MyInvocation.MyCommand.ScriptBlock.Module
            if (-not $myModule.DebuggingTypeNames) {
                $myModule |
                    Add-Member NoteProperty DebuggingTypeNames @() -Force
            }
            $MyInvocation.MyCommand.ScriptBlock.Module.DebuggingTypeNames += $TypeName
        }
    }

                    </Script>
      </ScriptMethod>
    </Members>
  </Type>
</Types>